<!DOCTYPE HTML>
<html lang="en">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="JavaSE学习基础篇, Hexo">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>JavaSE学习基础篇 | Hexo</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Hexo</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>Contact</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Hexo</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			About
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/11.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">JavaSE学习基础篇</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">No tag</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2021-04-07
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="JavaSE学习基础篇"><a href="#JavaSE学习基础篇" class="headerlink" title="JavaSE学习基础篇"></a>JavaSE学习基础篇</h1><p><img src="/images/123.png">       </p>
<h1 id="JavaSE简介"><a href="#JavaSE简介" class="headerlink" title="JavaSE简介"></a>JavaSE简介</h1><p><strong>javase是java standard edtion的缩写，译成中文就是java标准版，也是java的核心。无论是javaee(java企业版)还是javame(java微型版)都是以javase为基础。相当于它就是java的语法规则</strong></p>
<h1 id="学习JavaSE基础内容的流程简绍"><a href="#学习JavaSE基础内容的流程简绍" class="headerlink" title="学习JavaSE基础内容的流程简绍:"></a>学习JavaSE基础内容的流程简绍:</h1><p><strong>#chapter1： java语言概述</strong><br><strong>#chapter2： 基本语法</strong><br><strong>#chapter3： 数组</strong><br><strong>#chapter4 :   面向对象-上</strong><br><strong>#chapter5 :  面向对象-中</strong><br><strong>#chapter6 :  面向对象-下</strong><br><strong>#chapter7：异常处理</strong>  </p>
<h1 id="chapter-1-java语言概述"><a href="#chapter-1-java语言概述" class="headerlink" title="#chapter 1: java语言概述"></a>#chapter 1: java语言概述</h1><hr>
<p><img src="/images/java%E7%AE%80%E4%BB%8B.png" alt="java简介">  </p>
<h3 id="1-java语言概述"><a href="#1-java语言概述" class="headerlink" title="1. java语言概述"></a>1. java语言概述</h3><h4 id="1-1-java基础常识"><a href="#1-1-java基础常识" class="headerlink" title="1.1 java基础常识"></a>1.1 java基础常识</h4><p>软件：即一系列按照特定顺序组织的计算机数据和指令的集合。分为：系统软件 和 应用软件<br>系统软件：windows , mac os , linux ,unix,android,ios,….<br>应用软件：word ,ppt,画图板,…<br>人机交互方式： 图形化界面  vs  命令行方式<br>应用程序 = 算法 + 数据结构<br><font color="red">常用DOS命令：</font><br><img src="/images/dos%E5%91%BD%E4%BB%A4.png">          </p>
<h4 id="1-2-计算机语言的发展迭代史"><a href="#1-2-计算机语言的发展迭代史" class="headerlink" title="1.2 计算机语言的发展迭代史"></a>1.2 计算机语言的发展迭代史</h4><p>第一代：机器语言<br>第二代：汇编语言<br>第三代：高级语言        </p>
<ol>
<li>面向过程：C,Pascal、Fortran     </li>
<li>面向对象：Java,JS,Python,Scala,…             <h4 id="1-3-Java语言版本迭代概述"><a href="#1-3-Java语言版本迭代概述" class="headerlink" title="1.3 Java语言版本迭代概述"></a>1.3 Java语言版本迭代概述</h4>1991年 Green项目，开发语言最初命名为Oak (橡树)<br>1994年，开发组意识到Oak 非常适合于互联网<br>1996年，发布JDK 1.0，约8.3万个网页应用Java技术来制作<br>1997年，发布JDK 1.1，JavaOne会议召开，创当时全球同类会议规模之最<br>1998年，发布JDK 1.2，同年发布企业平台J2EE<br>1999年，Java分成J2SE、J2EE和J2ME，JSP/Servlet技术诞生<br>2004年，发布里程碑式版本：JDK 1.5，为突出此版本的重要性，更名为JDK 5.0<br>2005年，J2SE -&gt; JavaSE，J2EE -&gt; JavaEE，J2ME -&gt; JavaME<br>2009年，Oracle公司收购SUN，交易价格74亿美元<br>2011年，发布JDK 7.0<br>2014年，发布JDK 8.0，是继JDK 5.0以来变化最大的版本<br>2017年，发布JDK 9.0，最大限度实现模块化<br>2018年3月，发布JDK 10.0，版本号也称为18.3<br>2018年9月，发布JDK 11.0，版本号也称为18.9      <h4 id="1-4-Java语言应用的领域："><a href="#1-4-Java语言应用的领域：" class="headerlink" title="1.4 Java语言应用的领域："></a>1.4 Java语言应用的领域：</h4>Java Web开发：后台开发<br>大数据开发：<br>Android应用程序开发：客户端开发   <h4 id="1-5-Java语言的特点"><a href="#1-5-Java语言的特点" class="headerlink" title="1.5 Java语言的特点"></a>1.5 Java语言的特点</h4>面向对象性：<br>两个要素：类、对象<br>三个特征：封装、继承、多态<br>健壮性：① 去除了C语言中的指针 ②自动的垃圾回收机制 –&gt;仍然会出现内存溢出、内存泄漏<br>跨平台型：write once,run anywhere:一次编译，到处运行<br>功劳归功于：JVM<br><img src="/images/jvm.png">          <h3 id="2-开发环境搭建-重点"><a href="#2-开发环境搭建-重点" class="headerlink" title="2. 开发环境搭建(重点)"></a>2. 开发环境搭建(重点)</h3><h4 id="2-1-JDK、JRE、JVM的关系："><a href="#2-1-JDK、JRE、JVM的关系：" class="headerlink" title="2.1 JDK、JRE、JVM的关系："></a>2.1 JDK、JRE、JVM的关系：</h4><img src="/images/jdk_jre_jvm.png">       <h4 id="2-2-JDK的下载、安装"><a href="#2-2-JDK的下载、安装" class="headerlink" title="2.2 JDK的下载、安装"></a>2.2 JDK的下载、安装</h4>下载:官网<br>安装：傻瓜式安装：JDK 、JRE<br>注意问题：安装软件的路径中不能包含中文、空格。          </li>
</ol>
<h4 id="2-3-path环境变量的配置"><a href="#2-3-path环境变量的配置" class="headerlink" title="2.3 path环境变量的配置"></a>2.3 path环境变量的配置</h4><ol>
<li>为什么配置path环境变量？<br>path环境变量：windows操作系统执行命令时所要搜寻的路径<br>为什么要配置path:希望java的开发工具（javac.exe,java.exe)在任何的文件路径下都可以执行成功。     </li>
<li>如何配置？<br><img src="/images/jdk%E9%85%8D%E7%BD%AE.png">                   </li>
</ol>
<h3 id="3-开发第一个java程序"><a href="#3-开发第一个java程序" class="headerlink" title="3. 开发第一个java程序"></a>3. 开发第一个java程序</h3><h4 id="3-1-开发体验——HelloWorld"><a href="#3-1-开发体验——HelloWorld" class="headerlink" title="3.1 开发体验——HelloWorld"></a>3.1 开发体验——HelloWorld</h4><p><img src="/images/helloworld.png">      </p>
<h5 id="3-1-1-编写"><a href="#3-1-1-编写" class="headerlink" title="3.1.1 编写"></a>3.1.1 编写</h5><p>创建一个java源文件：HelloWorld.java     </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloChina</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-1-2-编译："><a href="#3-1-2-编译：" class="headerlink" title="3.1.2 编译："></a>3.1.2 编译：</h5><p>javac HelloWorld.java</p>
<h5 id="3-1-3-运行"><a href="#3-1-3-运行" class="headerlink" title="3.1.3 运行:"></a>3.1.3 运行:</h5><p>java HelloChina</p>
<h4 id="3-2-常见问题的解决"><a href="#3-2-常见问题的解决" class="headerlink" title="3.2 常见问题的解决"></a>3.2 常见问题的解决</h4><p><img src="/images/javacx.png"><br><img src="/images/javacx2.png">        </p>
<h4 id="3-3-总结第一个程序"><a href="#3-3-总结第一个程序" class="headerlink" title="3.3 总结第一个程序"></a>3.3 总结第一个程序</h4><ol>
<li>java程序编写-编译-运行的过程<br>编写：我们将编写的java代码保存在以”.java”结尾的源文件中<br>编译：使用javac.exe命令编译我们的java源文件。格式：javac 源文件名.java<br>运行：使用java.exe命令解释运行我们的字节码文件。 格式：java 类名         </li>
<li>在一个java源文件中可以声明多个class。但是，只能最多有一个类声明为public的。而且要求声明为public的类的类名必须与源文件名相同。        </li>
<li>程序的入口是main()方法。格式是固定的。       </li>
<li>输出语句：<br>System.out.println():先输出数据，然后换行<br>System.out.print():只输出数据        </li>
<li>每一行执行语句都以”;”结束。       </li>
<li>编译的过程：编译以后，会生成一个或多个字节码文件。字节码文件的文件名与java源文件中的类名相同。         <h3 id="4-java的注释和API文档"><a href="#4-java的注释和API文档" class="headerlink" title="4. java的注释和API文档"></a>4. java的注释和API文档</h3><h4 id="4-1-注释-Comment"><a href="#4-1-注释-Comment" class="headerlink" title="4.1 注释:Comment"></a>4.1 注释:Comment</h4>java有三种注释方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单行注释：&#x2F;&#x2F;</span><br><span class="line">多行注释：&#x2F;*    *&#x2F;</span><br><span class="line">文档注释：&#x2F;**    *&#x2F;</span><br></pre></td></tr></table></figure>
作用：可以对程序进行解释说明，增强可读。性方便自己，方便别人<br>特点:<br>单行注释和多行注释，注释了的内容不参与编译。<br>注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。<br>多行注释不可以嵌套使用    <h4 id="4-2-JavaAPI-文档"><a href="#4-2-JavaAPI-文档" class="headerlink" title="4.2 JavaAPI 文档"></a>4.2 JavaAPI 文档</h4>API:application programming interface。习惯上：将语言提供的类库，都称为api.<br>API文档：针对于提供的类库如何使用，给的一个说明书。类似于《新华字典》<h4 id="4-3-良好的编程风格"><a href="#4-3-良好的编程风格" class="headerlink" title="4.3 良好的编程风格"></a>4.3 良好的编程风格</h4><img src="/images/java_style.png">     </li>
</ol>
<h1 id="chapter-2：-基本语法"><a href="#chapter-2：-基本语法" class="headerlink" title="#chapter 2： 基本语法"></a>#chapter 2： 基本语法</h1><h3 id="1-关键字与表示符"><a href="#1-关键字与表示符" class="headerlink" title="1.关键字与表示符"></a>1.关键字与表示符</h3><h4 id="1-1-java关键字的使用"><a href="#1-1-java关键字的使用" class="headerlink" title="1.1 java关键字的使用"></a>1.1 java关键字的使用</h4><p>定义：被Java语言赋予了特殊含义，用做专门用途的字符串(单词)</p>
<p>特点：关键字中所有字母都为小写</p>
<p>具体那些关键字：</p>
<p><img src="/images/%E5%85%B3%E9%94%AE%E5%AD%971.png"></p>
<p><img src="/images/%E5%85%B3%E9%94%AE%E5%AD%972.png"></p>
<h4 id="1-2-保留字：现Java版本尚未使用，但以后版本可能会作为关键字使用。"><a href="#1-2-保留字：现Java版本尚未使用，但以后版本可能会作为关键字使用。" class="headerlink" title="1.2 保留字：现Java版本尚未使用，但以后版本可能会作为关键字使用。"></a>1.2 保留字：现Java版本尚未使用，但以后版本可能会作为关键字使用。</h4><p>具体哪些保留字：<strong>goto</strong> 、<strong>const</strong><br>注意：<strong>自己命名标识符时要避免使用这些保留字</strong></p>
<h4 id="1-3-标识符的使用"><a href="#1-3-标识符的使用" class="headerlink" title="1.3 标识符的使用"></a>1.3 标识符的使用</h4><p><strong>定义:凡是自己可以起名字的地方都叫标识符</strong><br>涉及到的结构:</p>
<p>包名、<strong>类名</strong>、接口名、<strong>变量名</strong>、<strong>方法名</strong>、常量名</p>
<p><font color="red">规则：(必须要遵守。否则，编译不通过)</font></p>
<p><img src="/images/%E6%A0%87%E8%AF%86%E7%AC%A6%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99.png"></p>
<p><font color="red">规范:（可以不遵守，不影响编译和运行。但是要求大家遵守<br>）</font></p>
<p><img src="/images/%E6%A0%87%E8%AF%86%E7%AC%A6%E8%A7%84%E8%8C%83.png"></p>
<p><strong>注意点：</strong> </p>
<ul>
<li>在起名字时，为了提高阅读性，要尽量意义，“见名知意”。    </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">代码整洁之道</span><br><span class="line">整理人：尚硅谷 - 宋红康</span><br><span class="line"></span><br><span class="line">第2章 有意义的命名</span><br><span class="line">2.1 介绍</span><br><span class="line">软件中随处可见命名。我们给变量、函数、参数、类和包命名。我们给源代码及源代码所在目录命名。</span><br><span class="line">这么多命名要做，不妨做好它。下文列出了取个好名字的几条简单规则。</span><br><span class="line"></span><br><span class="line">2.2 名副其实,见名知意</span><br><span class="line">   变量名太随意，haha、list1、ok、theList 这些都没啥意义</span><br><span class="line"></span><br><span class="line">2.3 避免误导</span><br><span class="line">   包含List、import、java等类名、关键字或特殊字；</span><br><span class="line">   字母o与数字0，字母l与数字1等</span><br><span class="line">   提防使用不同之处较小的名称。比如：XYZControllerForEfficientHandlingOfStrings与XYZControllerForEfficientStorageOfStrings</span><br><span class="line"></span><br><span class="line">2.4 做有意义的区分</span><br><span class="line">   反面教材，变量名：a1、a2、a3</span><br><span class="line">   避免冗余，不要出现Variable、表字段中避免出现table、字符串避免出现nameString，直接name就行，知道是字符串类型</span><br><span class="line">   再比如：定义了两个类：Customer类和CustomerObject类，如何区分？</span><br><span class="line">     定义了三个方法：getActiveAccount()、getActiveAccounts()、getActiveAccountInfo()，如何区分？</span><br><span class="line"></span><br><span class="line">2.5 使用读得出来的名称</span><br><span class="line">   不要使用自己拼凑出来的单词，比如：xsxm(学生姓名)；genymdhms(生成日期，年、月、日、时、分、秒)</span><br><span class="line">   所谓的驼峰命名法，尽量使用完整的单词</span><br><span class="line"></span><br><span class="line">2.6 使用可搜索的名称</span><br><span class="line">   一些常量，最好不直接使用数字，而指定一个变量名，这个变量名可以便于搜索到.</span><br><span class="line">   比如：找MAX_CLASSES_PER_STUDENT很容易，但想找数字7就麻烦了。</span><br><span class="line"></span><br><span class="line">2.7 避免使用编码</span><br><span class="line">   2.7.1 匈牙利语标记法</span><br><span class="line">         即变量名表明该变量数据类型的小写字母开始。例如，szCmdLine的前缀sz表示“以零结束的字符串”。</span><br><span class="line">   2.7.2 成员前缀</span><br><span class="line">        避免使用前缀，但是Android中一个比较好的喜欢用m表示私有等，个人感觉比较好</span><br><span class="line">   2.7.3 接口和实现</span><br><span class="line">        作者不喜欢把接口使用I来开头，实现也希望只是在后面添加Imp</span><br><span class="line"></span><br><span class="line">2.8 避免思维映射</span><br><span class="line">   比如传统上惯用单字母名称做循环计数器。所以就不要给一些非计数器的变量命名为：i、j、k等</span><br><span class="line"></span><br><span class="line">2.9  类名</span><br><span class="line">   类名与对象名应该是名词与名词短语。如Customer、WikiPage、Account和AddressParser。避免使用Data或Info这样的类名。</span><br><span class="line">   不能使动词。比如：Manage、Process</span><br><span class="line"></span><br><span class="line">2.10 方法名</span><br><span class="line">   方法名应当是动词或者动词短语。如postPayment、deletePage或save</span><br><span class="line"></span><br><span class="line">2.11 别扮可爱</span><br><span class="line">   有的变量名叫haha、banana</span><br><span class="line">   别用eatMyShorts()表示abort()</span><br><span class="line"></span><br><span class="line">2.12 每个概念对应一个词</span><br><span class="line">   项目中同时出现controllers与managers，为什么不统一使用其中一种？</span><br><span class="line">   对于那些会用到你代码的程序员，一以贯之的命名法简直就是天降福音。</span><br><span class="line"></span><br><span class="line">2.13 别用双关语</span><br><span class="line">   有时可能使用add并不合适，比例insert、append。add表示完整的新添加的含义。     </span><br><span class="line"></span><br><span class="line">2.14 使用解决方案领域名称</span><br><span class="line">   看代码的都是程序员，所以尽量用那些计算机科学术语、算法名、模式名、数学术语，</span><br><span class="line">   依据问题所涉领域来命名不算是聪明的做法。</span><br><span class="line"></span><br><span class="line">2.15 使用源自所涉问题领域的名称</span><br><span class="line">   如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉问题领域而来的名称吧。</span><br><span class="line">   至少，负责维护代码的程序员就能去请教领域专家了。</span><br><span class="line"></span><br><span class="line">2.16 添加有意义的语境</span><br><span class="line">   可以把相关的变量放到一个类中，使用这个类来表明语境。</span><br><span class="line"></span><br><span class="line">2.17 不要添加没用的语境</span><br><span class="line">   名字中带有项目的缩写，这样完全没有必要。比如有一个名为“加油站豪华版”（Gas Station Deluxe）的项目，</span><br><span class="line">   在其中给每个类添加GSD前缀就不是什么好策略。</span><br><span class="line"></span><br><span class="line">2.18 最后的话</span><br><span class="line">   取好名字最难的地方在于需要良好的描述技巧和共有文化背景。</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<h3 id="2-变量的使用（重点）"><a href="#2-变量的使用（重点）" class="headerlink" title="2.变量的使用（重点）"></a>2.变量的使用<font color="red">（重点）</font></h3><h4 id="2-1-变量的分类"><a href="#2-1-变量的分类" class="headerlink" title="2.1 变量的分类"></a>2.1 变量的分类</h4><h5 id="2-1-1-按数据类型分类"><a href="#2-1-1-按数据类型分类" class="headerlink" title="2.1.1 按数据类型分类"></a>2.1.1 按数据类型分类</h5><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB.png"></p>
<p>详细说明:</p>
<p>//1. 整型：byte(1字节=8bit) / short(2字节) / int(4字节) / long(8字节)<br>    //① byte范围：-128 ~ 127<br>// ② 声明long型变量，必须以”l”或”L”结尾<br>    // ③ 通常，定义整型变量时，使用int型。<br>     //④整型的常量，默认类型是：int型<br>//2. 浮点型：float(4字节) / double(8字节)<br>    //① 浮点型，表示带小数点的数值<br>    //② float表示数值的范围比long还大<br>//③ 定义float类型变量时，变量要以”f”或”F”结尾<br>//④ 通常，定义浮点型变量时，使用double型。<br>//⑤ 浮点型的常量，默认类型为：double<br>//3. 字符型：char (1字符=2字节)<br>    //① 定义char型变量，通常使用一对’’,内部只能写一个字符<br>//② 表示方式：1.声明一个字符 2.转义字符 3.直接使用 Unicode 值来表示字符型常量<br>//4.布尔型：boolean<br>//① 只能取两个值之一：true 、 false<br>//② 常常在条件判断、循环结构中使用</p>
<h5 id="2-1-2-按声明的位置分类-了解"><a href="#2-1-2-按声明的位置分类-了解" class="headerlink" title="2.1.2 按声明的位置分类(了解)"></a>2.1.2 按声明的位置分类(了解)</h5><p><img src="/images/%E5%A3%B0%E6%98%8E%E4%BD%8D%E7%BD%AE%E5%88%86%E7%B1%BB.png"></p>
<h4 id="2-2-定义变量的格式"><a href="#2-2-定义变量的格式" class="headerlink" title="2.2 定义变量的格式:"></a>2.2 定义变量的格式:</h4><p>数据类型     变量名    =     变量值;</p>
<p>或</p>
<p>数据类型  变量名;</p>
<p>变量名 = 变量值;</p>
<h4 id="2-3-变量使用的注意点："><a href="#2-3-变量使用的注意点：" class="headerlink" title="2.3 变量使用的注意点："></a>2.3 变量使用的注意点：</h4><p>① 变量必须先声明，后使用</p>
<p>② 变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了<br>③ 同一个作用域内，不可以声明两个同名的变量</p>
<h4 id="2-4-基本数据类型变量间运算规则"><a href="#2-4-基本数据类型变量间运算规则" class="headerlink" title="2.4 基本数据类型变量间运算规则"></a>2.4 基本数据类型变量间运算规则</h4><h5 id="2-4-1-涉及到的基本数据类型：除了boolean之外的其他7种"><a href="#2-4-1-涉及到的基本数据类型：除了boolean之外的其他7种" class="headerlink" title="2.4.1 涉及到的基本数据类型：除了boolean之外的其他7种"></a>2.4.1 涉及到的基本数据类型：除了boolean之外的其他7种</h5><h5 id="2-4-2-自动类型转换-只涉及7种基本数据类型）"><a href="#2-4-2-自动类型转换-只涉及7种基本数据类型）" class="headerlink" title="2.4.2 自动类型转换(只涉及7种基本数据类型）"></a>2.4.2 自动类型转换(只涉及7种基本数据类型）</h5><p>结论:当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。</p>
<p>​            byte、char、short、—&gt;int—&gt;long—&gt;float–&gt;double</p>
<p>特别的：当byte、char、short三种类型的变量做运算时，结果为int型</p>
<p>说明：此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量</p>
<h5 id="2-4-3-强制类型转换-只涉及7种基本数据类型）：自动类型提升运算的逆运算。"><a href="#2-4-3-强制类型转换-只涉及7种基本数据类型）：自动类型提升运算的逆运算。" class="headerlink" title="2.4.3 强制类型转换(只涉及7种基本数据类型）：自动类型提升运算的逆运算。"></a>2.4.3 强制类型转换(只涉及7种基本数据类型）：自动类型提升运算的逆运算。</h5><ol>
<li><p>需要注意使用强转符：()</p>
</li>
<li><p>注意点：强制类型转换，可能导致精度损失。</p>
</li>
</ol>
<h5 id="2-4-4-String与8种基本数据类型间的运算"><a href="#2-4-4-String与8种基本数据类型间的运算" class="headerlink" title="2.4.4 String与8种基本数据类型间的运算"></a>2.4.4 String与8种基本数据类型间的运算</h5><ol>
<li>String属于引用数据类型，翻译为：字符串</li>
<li>声明String类型变量时,使用一对””</li>
<li>String可以和8种基本数据类型变量做运算，运算只能是连接运算: +</li>
<li>运算的结果仍然是String类型</li>
<li>避免：<br>String s = 123;//编译错误<br> String s1 = “123”;<br> int i = (int)s1;//编译错误</li>
</ol>
<h3 id="3-进制-了解"><a href="#3-进制-了解" class="headerlink" title="3.进制(了解)"></a>3.进制(了解)</h3><h4 id="3-1-编程中涉及的进制及表示方式："><a href="#3-1-编程中涉及的进制及表示方式：" class="headerlink" title="3.1 编程中涉及的进制及表示方式："></a>3.1 编程中涉及的进制及表示方式：</h4><p><img src="/images/%E8%BF%9B%E5%88%B6%E7%9A%84%E4%BD%BF%E7%94%A8.png"></p>
<h3 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4.运算符"></a>4.运算符</h3><h4 id="4-1-算术运算符：-前-后-前-–-后-–"><a href="#4-1-算术运算符：-前-后-前-–-后-–" class="headerlink" title="4.1 算术运算符： + - + - * / % (前)++ (后)++ (前)– (后)– +"></a>4.1 算术运算符： + - + - * / % (前)++ (后)++ (前)– (后)– +</h4><p>1.//(前)++ :先自增1，后运算<br> //(后)++ :先运算，后自增1<br>2.//(前)– :先自减1，后运算<br>  //(后)– :先运算，后自减1<br>3.连接符：+：只能使用在String与其他数据类型变量之间使用。</p>
<h4 id="4-2-赋值运算符："><a href="#4-2-赋值运算符：" class="headerlink" title="4.2 赋值运算符：=     +=    -=    *=    /=    %="></a>4.2 赋值运算符：=     +=    -=    *=    /=    %=</h4><p>1.运算的结果不会改变变量本身的数据类型</p>
<p>2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开发中，如果希望变量实现+2的操作，有几种方法？(前提：int num = 10;)</span></span><br><span class="line"><span class="comment">//方式一：num = num + 2;</span></span><br><span class="line"><span class="comment">//方式二：num += 2; (推荐)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//开发中，如果希望变量实现+1的操作，有几种方法？(前提：int num = 10;)</span></span><br><span class="line"><span class="comment">//方式一：num = num + 1;</span></span><br><span class="line"><span class="comment">//方式二：num += 1; </span></span><br><span class="line"><span class="comment">//方式三：num++; (推荐)</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-比较运算符（关系运算符）-gt-lt-gt-lt-instanceof"><a href="#4-3-比较运算符（关系运算符）-gt-lt-gt-lt-instanceof" class="headerlink" title="4.3 比较运算符（关系运算符）: == != &gt;  &lt;  &gt;=  &lt;=  instanceof"></a>4.3 比较运算符（关系运算符）: == != &gt;  &lt;  &gt;=  &lt;=  instanceof</h4><p>1.比较运算符的结果是boolean类型<br>2.&gt;  &lt;  &gt;=  &lt;= :只能使用在数值类型的数据之间。</p>
<p>3.== 和 !=: 不仅可以使用在数值类型数据之间，还可以使用在其他引用类型变量之间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Account acct1 = <span class="keyword">new</span> Account(<span class="number">1000</span>);</span><br><span class="line">Account acct2 = <span class="keyword">new</span> Account(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">boolean</span> b1 = (acct1 == acct2);<span class="comment">//比较两个Account是否是同一个账户。</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = (acct1 != acct2);<span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h4 id="4-4-逻辑运算符：-amp-amp-amp"><a href="#4-4-逻辑运算符：-amp-amp-amp" class="headerlink" title="4.4 逻辑运算符：&amp; &amp;&amp;  |  || !  ^"></a>4.4 逻辑运算符：&amp; &amp;&amp;  |  || !  ^</h4><p>//区分&amp; 与 &amp;&amp;<br>        //相同点1：&amp; 与  &amp;&amp; 的运算结果相同<br>        //相同点2：当符号左边是true时，二者都会执行符号右边的运算<br>        //不同点：当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算。<br>        //开发中，推荐使用&amp;&amp;</p>
<p>// 区分：| 与 ||<br>        //相同点1：| 与  || 的运算结果相同<br>        //相同点2：当符号左边是false时，二者都会执行符号右边的运算<br>        //不同点3：当符号左边是true时，|继续执行符号右边的运算，而||不再执行符号右边的运算<br>        //开发中，推荐使用||</p>
<p>1.逻辑运算符操作的都是boolean类型的变量。而且结果也是boolean类型</p>
<h4 id="4-5-位运算符：-lt-lt-gt-gt-gt-gt-gt-amp"><a href="#4-5-位运算符：-lt-lt-gt-gt-gt-gt-gt-amp" class="headerlink" title="4.5 位运算符：&lt;&lt;  &gt;&gt; &gt;&gt;&gt; &amp;  |  ^  ~"></a>4.5 位运算符：&lt;&lt;  &gt;&gt; &gt;&gt;&gt; &amp;  |  ^  ~</h4><ol>
<li>位运算符操作的都是整型的数据</li>
<li>&lt;&lt; ：在一定范围内，每向左移1位，相当于 * 2   &gt;&gt;:在一定范围内，每向右移1位，相当于 / 2</li>
</ol>
<p>典型题目：<br>1.交换两个变量的值。<br>2.实现60的二进制到十六进制的转换</p>
<h4 id="4-6-三元运算符：-条件表达式-表达式1-表达式2"><a href="#4-6-三元运算符：-条件表达式-表达式1-表达式2" class="headerlink" title="4.6 三元运算符：(条件表达式)? 表达式1 : 表达式2"></a>4.6 三元运算符：(条件表达式)? 表达式1 : 表达式2</h4><p>1.根据条件表达式真或假，决定执行表达式1，还是表达式2.<br>     如果表达式为true，则执行表达式1。<br>     如果表达式为false，则执行表达式2。</p>
<p>2.三元运算符可以嵌套使用</p>
<p>3.如果程序既可以使用三元运算符，又可以使用if-else结构，那么优先选择三元运算符。原因：简洁、执行效率高。</p>
<h3 id="5-流程控制"><a href="#5-流程控制" class="headerlink" title="5.流程控制"></a>5.流程控制</h3><p>顺序结构：程序从上到下执行。</p>
<p>分支结构：<br>if-else if - else<br>switch-case</p>
<p>循环结构：<br>for<br>while<br>do-while</p>
<h4 id="5-1-分支结构"><a href="#5-1-分支结构" class="headerlink" title="5.1 分支结构"></a>5.1 分支结构</h4><h5 id="5-1-1-if-else条件判断结构"><a href="#5-1-1-if-else条件判断结构" class="headerlink" title="5.1.1 if-else条件判断结构"></a>5.1.1 if-else条件判断结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">结构一：</span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	执行表达式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结构二：二选一</span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	执行表达式<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	执行表达式<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结构三：n选一</span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	执行表达式<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	执行表达式<span class="number">2</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	执行表达式<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">	执行表达式n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><ol>
<li><p>else 结构是可选的。</p>
</li>
<li><p>针对于条件表达式：</p>
<blockquote>
<p>如果多个条件表达式之间是“互斥”关系(或没有交集的关系),哪个判断和执行语句声明在上面还是下面，无所谓。<br>如果多个条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面。<br>如果多个条件表达式之间有包含的关系，通常情况下，需要将范围小的声明在范围大的上面。否则，范围小的就没机会执行了。</p>
</blockquote>
</li>
<li><p>if-else结构是可以相互嵌套的。</p>
</li>
<li><p>如果if-else结构中的执行语句只有一行时，对应的一对{}可以省略的。但是，不建议大家省略。 </p>
</li>
</ol>
<h5 id="5-1-2-switch-case选择结构"><a href="#5-1-2-switch-case选择结构" class="headerlink" title="5.1.2 switch-case选择结构"></a>5.1.2 switch-case选择结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">		执行语句<span class="number">1</span>;</span><br><span class="line">		<span class="comment">//break;</span></span><br><span class="line">	<span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">		执行语句<span class="number">2</span>;</span><br><span class="line">		<span class="comment">//break;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		执行语句n;</span><br><span class="line">		<span class="comment">//break;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h5><p>① 根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。<br>  当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构<br>  末尾结束为止。<br>② break,可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构<br>③ switch结构中的表达式，只能是如下的6种数据类型之一：<br>   byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)<br>④ case 之后只能声明常量。不能声明范围。<br>⑤ break关键字是可选的。<br>⑥ default:相当于if-else结构中的else.<br>  default结构是可选的，而且位置是灵活的。<br>3.如果switch-case结构中的多个case的执行语句相同，则可以考虑进行合并。<br>4.break在switch-case中是可选的</p>
<h4 id="5-2-循环结构"><a href="#5-2-循环结构" class="headerlink" title="5.2 循环结构"></a>5.2 循环结构</h4><h5 id="5-2-1-循环结构的四要素"><a href="#5-2-1-循环结构的四要素" class="headerlink" title="5.2.1 循环结构的四要素"></a>5.2.1 循环结构的四要素</h5><p>① 初始化条件<br>② 循环条件  —&gt;是boolean类型<br>③ 循环体<br>④ 迭代条件<br>说明：通常情况下，循环结束都是因为②中循环条件返回false了。</p>
<h5 id="5-2-2-三种循环结构："><a href="#5-2-2-三种循环结构：" class="headerlink" title="5.2.2 三种循环结构："></a>5.2.2 三种循环结构：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(①;②;④)&#123;</span><br><span class="line">	③</span><br><span class="line">&#125;</span><br><span class="line">执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ②</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(②)&#123;</span><br><span class="line">	③;</span><br><span class="line">	④;</span><br><span class="line">&#125;</span><br><span class="line">执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ②</span><br><span class="line"></span><br><span class="line">①</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	③;</span><br><span class="line">	④;</span><br><span class="line">&#125;<span class="keyword">while</span>(②);</span><br><span class="line">执行过程：① - ③ - ④ - ② - ③ - ④ - ... - ②</span><br></pre></td></tr></table></figure>

<h5 id="5-2-3-说明："><a href="#5-2-3-说明：" class="headerlink" title="5.2.3 说明："></a>5.2.3 说明：</h5><p><font color="red">写while循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！</font></p>
<p><strong>for和while循环总结:</strong></p>
<ol>
<li>开发中，基本上我们都会从for、while中进行选择，实现循环结构。</li>
<li>for循环和while循环是可以相互转换的!  区别：for循环和while循环的初始化条件部分的作用范围不同。</li>
<li>我们写程序，要避免写死循环。</li>
</ol>
<p><strong>do-while循环总结</strong></p>
<ol>
<li>do-while循环至少执行一次循环体！</li>
<li>开发中，使用for和while更多一些。较少使用do-while</li>
</ol>
<h5 id="5-2-4-“无限循环”结构-while-true-或-for"><a href="#5-2-4-“无限循环”结构-while-true-或-for" class="headerlink" title="5.2.4 “无限循环”结构: while(true) 或 for(;;)"></a>5.2.4 “无限循环”结构: while(true) 或 for(;;)</h5><p><strong>总结</strong></p>
<ol>
<li>当循环条件是false时</li>
<li>在循环体中，执行break</li>
</ol>
<h5 id="5-2-5-嵌套循环"><a href="#5-2-5-嵌套循环" class="headerlink" title="5.2.5 嵌套循环"></a>5.2.5 嵌套循环</h5><ol>
<li><p>嵌套循环：将一个循环结构A声明在另一个循环结构B的循环体中，就构成了嵌套循环</p>
<p>内层循环：循环结构A<br>外层循环：循环结构B</p>
</li>
</ol>
<p><strong>说明</strong></p>
<p>① 内层循环结构遍历一遍，只相当于外层循环循环体执行了一次<br>② 假设外层循环需要执行m次，内层循环需要执行n次。此时内层循环的循环体一共执行了m * n次<br>③ 外层循环控制行数，内层循环控制列数</p>
<p><strong>补充:衡量一个功能代码的优劣：</strong><br>1.正确性<br>2.可读性<br>3.健壮性<br>4.高效率与低存储：时间复杂度 、空间复杂度 （衡量算法的好坏）</p>
<h4 id="5-3-关键字break-和-continued的使用"><a href="#5-3-关键字break-和-continued的使用" class="headerlink" title="5.3 关键字break 和 continued的使用"></a>5.3 关键字break 和 continued的使用</h4><table>
<thead>
<tr>
<th></th>
<th>使用范围</th>
<th>循环中使用的作用(不同点)</th>
<th>相同点</th>
</tr>
</thead>
<tbody><tr>
<td>break</td>
<td>switch-case  <br>循环体结构中</td>
<td>结束当前循环</td>
<td>关键字后面不能声明执行</td>
</tr>
<tr>
<td>continue</td>
<td>循环体结构中</td>
<td>结束当次循环</td>
<td>关键字后面不能声明执行</td>
</tr>
</tbody></table>
<h4 id="5-4-如何从键盘中获取不同类型的变量：-需要使用Scanner类"><a href="#5-4-如何从键盘中获取不同类型的变量：-需要使用Scanner类" class="headerlink" title="5.4 如何从键盘中获取不同类型的变量： 需要使用Scanner类"></a>5.4 如何从键盘中获取不同类型的变量： 需要使用Scanner类</h4><p><strong>具体实现步骤:</strong></p>
<ol>
<li>导包： import java.util.Scanner</li>
<li>Scanner的实例化Scanner in = new Scanner(System.in);</li>
<li>调用Scanner类的相关方法(next()/nextXxx())，来获取指定类型的变量</li>
</ol>
<h3 id="总结代码"><a href="#总结代码" class="headerlink" title="总结代码"></a><font color="gree">总结代码</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day01;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 26个英文字母，0-9,_或$组成</span></span><br><span class="line"><span class="comment"> * 数字不能是开头</span></span><br><span class="line"><span class="comment"> * java命名规范</span></span><br><span class="line"><span class="comment"> * 包名：多个单词组成时字母都小写：xxxyyyzzz</span></span><br><span class="line"><span class="comment"> * 类名、接口名：多单词时，所有首字母大写XxxYyyZzz</span></span><br><span class="line"><span class="comment"> * 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</span></span><br><span class="line"><span class="comment"> * 4.</span></span><br><span class="line"><span class="comment"> * 		尽量要见名知意</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdentifierTest</span> </span>&#123;<span class="comment">//Identifier标识符</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> myNumber = <span class="number">1001</span>;</span><br><span class="line">		System.out.println(myNumber);</span><br><span class="line">		<span class="keyword">long</span> l1 = <span class="number">10L</span>;</span><br><span class="line">		<span class="comment">//声明long 型变量，必须以“l”或“L”结尾</span></span><br><span class="line">		System.out.println(l1);</span><br><span class="line">		<span class="keyword">float</span> f1 = <span class="number">12.3f</span>;</span><br><span class="line">		<span class="comment">//声明float 变量时必须以“f”，或“F”结尾</span></span><br><span class="line">		System.out.println(f1);</span><br><span class="line"><span class="comment">//	byte、char、short--&gt;int --&gt; long --&gt; float --&gt; double</span></span><br><span class="line">	<span class="comment">//byte、char、short之间运算的结果全都是int型</span></span><br><span class="line">		<span class="keyword">byte</span> b1 = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">char</span> c1 = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">		<span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> i1 = b1 + c1;</span><br><span class="line">		<span class="keyword">int</span> i2 = b1 + s1;</span><br><span class="line">		System.out.println(i1 + <span class="string">&quot; &quot;</span> + i2);</span><br><span class="line">		<span class="comment">//编码情况</span></span><br><span class="line">		<span class="keyword">long</span> l = <span class="number">123123</span>;</span><br><span class="line">		System.out.println(l);</span><br><span class="line">		<span class="comment">//编译失败过大整数</span></span><br><span class="line"><span class="comment">//		long l2 = 564654654654655;</span></span><br><span class="line">		<span class="comment">//不加L，l就相当于是int型；</span></span><br><span class="line">		<span class="comment">//加L,l才相当于是long型</span></span><br><span class="line">		<span class="keyword">long</span> l2 = <span class="number">564654654654655L</span>;</span><br><span class="line">		<span class="comment">/*引用数据类型有 ：类、接口、数组；</span></span><br><span class="line"><span class="comment">		 * 1.String 不是基本数据类型、</span></span><br><span class="line"><span class="comment">		 * 	是一个引用数据类型</span></span><br><span class="line"><span class="comment">		 * 2.声明String类型变量时，使用一对&quot;&quot;;</span></span><br><span class="line"><span class="comment">		 * 3.String 可以和8种数据类型进行运算，并且运算只能是连接运算：+</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">int</span> number = <span class="number">1001</span>;</span><br><span class="line">		String numberStr = <span class="string">&quot;学号：&quot;</span>;</span><br><span class="line">		numberStr = numberStr + number;</span><br><span class="line">		System.out.println(numberStr);</span><br><span class="line">		<span class="keyword">boolean</span> i = <span class="keyword">true</span>;</span><br><span class="line">		System.out.println(numberStr + i);</span><br><span class="line">		System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27;/t&#x27;</span> + <span class="string">&quot;*&quot;</span>);<span class="comment">//&#x27;*&#x27; = 42</span></span><br><span class="line">		System.out.println(<span class="string">&quot;*    *&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&#x27;/t&#x27;</span> + <span class="number">1</span>);<span class="comment">///t = 9</span></span><br><span class="line">		System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27;/t&#x27;</span> + <span class="string">&#x27;*&#x27;</span>);<span class="comment">//93</span></span><br><span class="line">		System.out.println(<span class="string">&quot;*&quot;</span> + <span class="string">&#x27;/t&#x27;</span> + <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">		System.out.println(<span class="string">&#x27;*&#x27;</span> + (<span class="string">&#x27;/t&#x27;</span> + <span class="string">&quot;*&quot;</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 二进制以0b或0B开头</span></span><br><span class="line"><span class="comment"> * 八进制以0开头</span></span><br><span class="line"><span class="comment"> * 十六进制以0x或0X开头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">		<span class="keyword">int</span> num1 = <span class="number">0b110</span>;</span><br><span class="line">		<span class="keyword">int</span> num2 = <span class="number">110</span>;</span><br><span class="line">		<span class="keyword">int</span> num3 = <span class="number">0127</span>;</span><br><span class="line">		<span class="keyword">int</span> num4 = <span class="number">0x110A</span>;</span><br><span class="line">		System.out.println(num1);</span><br><span class="line">		System.out.println(num2);</span><br><span class="line">		System.out.println(num3);</span><br><span class="line">		System.out.println(num4);</span><br><span class="line">		<span class="keyword">int</span> a1 = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//前++：先自增1,后运算</span></span><br><span class="line">		<span class="keyword">int</span> b11 = ++a1;</span><br><span class="line">		<span class="comment">//后++:先运算再自增1</span></span><br><span class="line">		<span class="keyword">int</span> b2 = a1++;</span><br><span class="line">		System.out.println(b11 + <span class="string">&quot; &quot;</span> +  b2);</span><br><span class="line">		<span class="keyword">short</span> s2 = <span class="number">10</span>;</span><br><span class="line">		s2 = (<span class="keyword">short</span>)(s2 + <span class="number">2</span>);</span><br><span class="line">		s2 += <span class="number">2</span>;<span class="comment">//(推荐)</span></span><br><span class="line">		<span class="comment">//这种写法不会改变数据类型</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * &amp; &amp;&amp;短路与 | ||短路或 ！ ^短路非</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//&amp; 与 &amp;&amp;</span></span><br><span class="line">		<span class="comment">//相同点1：&amp; 与 &amp;&amp; 的运算结果相同</span></span><br><span class="line">		<span class="comment">//相同点2：当符号左边是true时，二者都会执行符号右边的运算</span></span><br><span class="line">		<span class="comment">//不通点：当符号左边是false时，&amp;继续执行符号右边的运算&amp;&amp;就不会执行右边的运算</span></span><br><span class="line">		<span class="keyword">boolean</span> bb1 = <span class="keyword">true</span>;</span><br><span class="line">		bb1 = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">int</span> number1 = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span>( bb1 &amp; (number1++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;我现在在北京&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;我现在在南京&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;number1 =&quot;</span>+number1);</span><br><span class="line">		<span class="keyword">boolean</span> bb2 = <span class="keyword">true</span>;</span><br><span class="line">		bb2 = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">int</span> number2 = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span>(bb2 &amp;&amp; (number2++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;我现在在北京&quot;</span>);</span><br><span class="line">			</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;我现在在南京&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;number2 +&quot;</span>+number2);</span><br><span class="line">		<span class="comment">//区分 | 与||</span></span><br><span class="line">		<span class="comment">//同上</span></span><br><span class="line">		<span class="comment">//位运算符</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * &lt;&lt; 左移 ，&gt;&gt; 右移, &gt;&gt;&gt;无符号右移</span></span><br><span class="line"><span class="comment">		 * &amp;与运算|或运算^异或运算~取反运算</span></span><br><span class="line"><span class="comment">		 * 是相对于二进制的</span></span><br><span class="line"><span class="comment">		 * 21</span></span><br><span class="line"><span class="comment">		 * 21&lt;&lt;2左移2位</span></span><br><span class="line"><span class="comment">		 * 二进制为</span></span><br><span class="line"><span class="comment">		 * 0000 0001 0101</span></span><br><span class="line"><span class="comment">		 * 左移2位</span></span><br><span class="line"><span class="comment">		 * 0000 0101 0100 </span></span><br><span class="line"><span class="comment">		 * 没向左移一位相当于*2</span></span><br><span class="line"><span class="comment">		 * &gt;&gt;右移/2</span></span><br><span class="line"><span class="comment">		 * &gt;&gt;&gt;不管移动的是正数还是负数右移之后都是正数</span></span><br><span class="line"><span class="comment">		 * 因为头的判断正负的01全都换成了0；</span></span><br><span class="line"><span class="comment">		 * 右移&lt;&lt;首是1拿1 补；</span></span><br><span class="line"><span class="comment">		 * &amp;|^</span></span><br><span class="line"><span class="comment">		 *  00001100 12</span></span><br><span class="line"><span class="comment">		 * &amp;00000101 5</span></span><br><span class="line"><span class="comment">		 * 	00000100与运算计算得出</span></span><br><span class="line"><span class="comment">		 * | ^ 与上面相同；</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//如何最高效的计算2 * 8 ：2&lt;&lt;3 或 8&lt;&lt;1;</span></span><br><span class="line">		<span class="keyword">int</span> o = <span class="number">21</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;o&lt;&lt;2 :&quot;</span>+(o&lt;&lt;<span class="number">2</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;***********&quot;</span>);</span><br><span class="line">		System.out.println(-<span class="number">26</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		System.out.println(-<span class="number">26</span>&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		System.out.println(-<span class="number">26</span>&gt;&gt;<span class="number">2</span>);</span><br><span class="line">		System.out.println(-<span class="number">26</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;************&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> numb3 = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">int</span> numb4 = <span class="number">20</span>;</span><br><span class="line">		numb3 = numb3 + numb4;</span><br><span class="line">		numb4 = numb3 - numb4;</span><br><span class="line">		numb3 = numb3 - numb4;</span><br><span class="line">		<span class="comment">//好处不用创建新变量</span></span><br><span class="line">		<span class="comment">//1.有弊端可能超出数值范围；</span></span><br><span class="line">		<span class="comment">//2.有局限性只能进行数值型的交换；</span></span><br><span class="line">		<span class="keyword">int</span> m = <span class="number">13</span>;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">		m = n ^ m;</span><br><span class="line">		n = m ^ n;</span><br><span class="line">		m = m ^ n;</span><br><span class="line">		System.out.println(<span class="string">&quot;n m &quot;</span> + n + <span class="string">&quot;  &quot;</span>+ m);</span><br><span class="line">		<span class="comment">//三元运算符</span></span><br><span class="line">		<span class="comment">//(条件表达式)？表达式1：表达式2</span></span><br><span class="line">		<span class="comment">//条件表达式的结果为boolean类型</span></span><br><span class="line">		<span class="comment">//根据条件表达式真或假，决定执行表达式1，还是表达式2.</span></span><br><span class="line">		<span class="comment">//如果表达式是true，则执行表达式1.</span></span><br><span class="line">		<span class="comment">//如果表达式是false,则执行表达式2.</span></span><br><span class="line">		<span class="comment">//三元运算符可以嵌套使用</span></span><br><span class="line"><span class="comment">//	3.	</span></span><br><span class="line">		<span class="comment">//凡是可以使用三元运算符的地方，都可以改写为if-else反之不成立</span></span><br><span class="line"><span class="comment">//	4.   </span></span><br><span class="line">		<span class="comment">//如果程序可以使用三元也可以用if-else优先选择三元。</span></span><br><span class="line">		<span class="comment">//原因：简洁、执行效率高。</span></span><br><span class="line">		<span class="keyword">int</span> m1 = <span class="number">12</span>;</span><br><span class="line">		<span class="keyword">int</span> n1 = <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">int</span> max = (m1 &gt; n1)? m1 : n1;</span><br><span class="line">		System.out.println(max);</span><br><span class="line">		String maxStr = (m1 &gt; n1) ? <span class="string">&quot;m1大&quot;</span> : <span class="string">&quot;n1大&quot;</span>;</span><br><span class="line">		System.out.println(maxStr);</span><br><span class="line">		m1 = n1;</span><br><span class="line">		String maxStr1 = (m1 &gt; n1) ? <span class="string">&quot;m1大&quot;</span> : ((m1 == n1) ? <span class="string">&quot;m1和n1相等&quot;</span> : <span class="string">&quot;n1大&quot;</span>);</span><br><span class="line">		System.out.println(maxStr1);</span><br><span class="line">		<span class="comment">//获取三个值中的最大值</span></span><br><span class="line">		<span class="keyword">int</span> o1 = <span class="number">23</span>;</span><br><span class="line">		<span class="comment">//不建议这样写代码帅气的点在于运行效率高而不是行数少看起来复杂</span></span><br><span class="line">		<span class="comment">//int maxThree = (m1 &gt; n1) ? ((m1 &gt; o1) ? m1 : o1) : ((n1 &gt; o1) ? n1 :o1);</span></span><br><span class="line"><span class="comment">//		System.out.println(maxThree);</span></span><br><span class="line">		<span class="comment">//优先级考虑直接让先算的加()就不用受影响了</span></span><br><span class="line">	&#125;		 </span><br><span class="line">&#125;			 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 程序流程控制</span></span><br><span class="line"><span class="comment">	 * 1. 顺序结构</span></span><br><span class="line"><span class="comment">	 * 2. 分支结构</span></span><br><span class="line"><span class="comment">	 * 3. 循环结构</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//分支结构</span></span><br><span class="line">	<span class="comment">//if-else条件判断结构;</span></span><br><span class="line">	<span class="comment">//三种形式</span></span><br><span class="line">	<span class="comment">//if(条件表达式)&#123;&#125;</span></span><br><span class="line">	<span class="comment">//if(条件表达式)&#123;&#125;else(条件表达式)&#123;&#125;</span></span><br><span class="line">	<span class="comment">//if(条件表达式)&#123;&#125;else if(条件表达式)&#123;&#125;.....else&#123;&#125;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//举例1</span></span><br><span class="line">		<span class="keyword">int</span> heartBeats = <span class="number">79</span>;</span><br><span class="line">		<span class="keyword">if</span>(heartBeats &lt; <span class="number">60</span> || heartBeats &gt;<span class="number">100</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;需要做进一步检查&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;检查结束&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//举例2</span></span><br><span class="line">		<span class="keyword">int</span> age = <span class="number">23</span>;</span><br><span class="line">		<span class="keyword">if</span>(age &lt; <span class="number">18</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;你还可以看动画哦&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;你可以看成人电影了&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//举例3</span></span><br><span class="line">		<span class="keyword">if</span>(age &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;您输入的数据非法&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(age &lt; <span class="number">35</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;青少年时期&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(age &lt; <span class="number">60</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;中年时期&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(age &lt; <span class="number">120</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;老年时期&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;成仙了&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//连接符+只能连接String 或String与其他类型之间；</span></span><br><span class="line"><span class="comment">//  ==  !=：不仅可以使用在数值 类型之间，还可以使用在其他引用类型变量之间。</span></span><br><span class="line">		<span class="comment">//Accout acct1 = new Accout(1000);</span></span><br><span class="line">		<span class="comment">//Accout acct2 = new Accout(2000);</span></span><br><span class="line">		<span class="comment">//boolean b1 = (acct1 == acct2)//比较Accout是否是同一个账户</span></span><br><span class="line">		<span class="comment">//boolean b2 = (acct1 != acct2)</span></span><br><span class="line"><span class="comment">//		求一个0~255范围内的整数十六进制值，例如60的十六进制为3c</span></span><br><span class="line">		<span class="comment">//方法一：自动实现</span></span><br><span class="line">		String str3 = Integer.toBinaryString(<span class="number">60</span>);<span class="comment">//Binary 二进制编码</span></span><br><span class="line">		String str4 = Integer.toHexString(<span class="number">60</span>);<span class="comment">//hex 十六进制</span></span><br><span class="line">		System.out.println(str3);</span><br><span class="line">		System.out.println(str4);</span><br><span class="line">		<span class="comment">//方法二：</span></span><br><span class="line">		<span class="keyword">int</span> i1 = <span class="number">60</span>;</span><br><span class="line">		<span class="keyword">int</span> i2 = i1&amp;<span class="number">15</span>;</span><br><span class="line">		System.out.println(i2);</span><br><span class="line">		String j = (i2 &gt; <span class="number">9</span>)? (<span class="keyword">char</span>)(i2-<span class="number">10</span>+<span class="string">&#x27;A&#x27;</span>)+<span class="string">&quot;&quot;</span> : i2 + <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">int</span> temp = i1 &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">		i2 = temp &amp; <span class="number">15</span>;</span><br><span class="line">		String k = (i2 &gt; <span class="number">9</span>)? (<span class="keyword">char</span>)(i2-<span class="number">10</span>+<span class="string">&#x27;A&#x27;</span>) + <span class="string">&quot;&quot;</span> : i2 + <span class="string">&quot;&quot;</span>;</span><br><span class="line">		System.out.println(k+<span class="string">&quot;&quot;</span>+j);</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入你的姓名：&quot;</span>);</span><br><span class="line">		String name = in.next();</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入你的芳龄：&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> age1 = in.nextInt();</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入你的体重：&quot;</span>);</span><br><span class="line">		<span class="keyword">double</span> weight = in.nextDouble();</span><br><span class="line">		System.out.println(<span class="string">&quot;你是否相中了我：&quot;</span>);</span><br><span class="line">		<span class="keyword">boolean</span> isLove = in.nextBoolean(); </span><br><span class="line">		System.out.println(isLove);</span><br><span class="line">		<span class="comment">//对于char型的获取，Scanner没有提供相关的方法。只能获取一个字符串</span></span><br><span class="line">		System.out.println(<span class="string">&quot;请输入你的性别：(男/女)&quot;</span>);</span><br><span class="line">		String gender = in.next();<span class="comment">//男</span></span><br><span class="line">		<span class="keyword">char</span> genderChar = gender.charAt(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">//charAt(int index)获取字符串第几个位置上的字符</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 首先，next（）一定要读取到有效字符后才可以结束输入，对输入有效字符之前遇到的空格键、Tab键或Enter键等结束符，next（）方法会自动将其去掉，只有在输入有效字符之后，next（）方法才将其后输入的空格键、Tab键或Enter键等视为分隔符或结束符。简单地说，next（）查找并返回来自此扫描器的下一个完整标记。完整标记的前后是与分隔模式匹配的输入信息，所以next方法不能得到带空格的字符串而nextLine（）方法的结束符只是Enter键，即nextLine（）方法返回的是Enter键之前的所有字符，它是可以得到带空格的字符串的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> looptest;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For循环结构的使用</span></span><br><span class="line"><span class="comment"> * 一、循环结构的4个要素</span></span><br><span class="line"><span class="comment"> * 1.初始化条件</span></span><br><span class="line"><span class="comment"> * 2.循环条件  ---&gt;是boolean类型</span></span><br><span class="line"><span class="comment"> * 3.循环体</span></span><br><span class="line"><span class="comment"> * 4.迭代条件</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 二.for循环的结构</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * for(1;2;4)&#123;</span></span><br><span class="line"><span class="comment"> *		3 </span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * 执行过程1-2-3-4-2-3-4-2-3-4-....-2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopTest1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(System.out.print(<span class="string">&quot;a&quot;</span>); num &lt;= <span class="number">3</span>; System.out.print(<span class="string">&quot;c&quot;</span>),num++)&#123;</span><br><span class="line">			System.out.print(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">		&#125;<span class="comment">//i只在定义它的for循环里面有用</span></span><br><span class="line">		System.out.println();</span><br><span class="line">		<span class="comment">//遍历100以内的偶数，输出所有偶数之和；</span></span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//记录偶数的个数  count 计数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">				System.out.println(i);</span><br><span class="line">				sum += i;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 分支结构之二：switch - case</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.格式</span></span><br><span class="line"><span class="comment"> *  switch(表达式)&#123;</span></span><br><span class="line"><span class="comment"> *  case 常量1:</span></span><br><span class="line"><span class="comment"> *  	执行语句1;</span></span><br><span class="line"><span class="comment"> *  	//break;</span></span><br><span class="line"><span class="comment"> *  case 常量2:</span></span><br><span class="line"><span class="comment"> *  	执行语句2;</span></span><br><span class="line"><span class="comment"> *  	//break;</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  .......</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  default: default 违约</span></span><br><span class="line"><span class="comment"> *  	执行语句;</span></span><br><span class="line"><span class="comment"> *  	//break;</span></span><br><span class="line"><span class="comment"> *  &#125;</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  2.说明：</span></span><br><span class="line"><span class="comment"> *	1.根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。</span></span><br><span class="line"><span class="comment"> *	当调用完执行语句以后，则仍然继续向下执行其他的case结构中的执行语句，直到遇到break关键字或此switch-case结构结束为止。</span></span><br><span class="line"><span class="comment"> *	2.break, 可以使用在switch-case结构中，表示一旦执行此关键字，就跳出switch-case结构</span></span><br><span class="line"><span class="comment"> *	3.switch结构中的表达式只能是如下的六种类型之一：byte、short、char、int、枚举类型（JDK5.0新增）、String类型（JDK7.0新增）。</span></span><br><span class="line"><span class="comment"> *	4.case之后只能声明常量，不能声明范围。</span></span><br><span class="line"><span class="comment"> *	5.break关键字是可选的。</span></span><br><span class="line"><span class="comment"> *	6.default 相当于else  default是可选的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchCaseTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> number = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">switch</span>(number)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			System.out.println(<span class="string">&quot;zero&quot;</span>);</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			System.out.println(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			System.out.println(<span class="string">&quot;two&quot;</span>);</span><br><span class="line"><span class="comment">//			break;</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			System.out.println(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		String season = <span class="string">&quot;summer&quot;</span>;</span><br><span class="line">		<span class="keyword">switch</span> (season)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;spring&quot;</span>:</span><br><span class="line">			System.out.println(<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;summer&quot;</span>:</span><br><span class="line">			System.out.println(<span class="string">&quot;炎炎夏日&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;autum&quot;</span>:</span><br><span class="line">			System.out.println(<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;winter&quot;</span>:</span><br><span class="line">			System.out.println(<span class="string">&quot;冬雪皑皑&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			System.out.println(<span class="string">&quot;季节输入有误&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果switch-case结构中的多个case的执行语句相同，则可以考虑进行合并</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">int</span> score = <span class="number">78</span>;<span class="comment">//score 分数</span></span><br><span class="line">		<span class="keyword">switch</span>(score/<span class="number">10</span>)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">			System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">			System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//更优</span></span><br><span class="line">		<span class="keyword">switch</span> (score / <span class="number">60</span>)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> month = <span class="number">6</span>;<span class="comment">//month 月份</span></span><br><span class="line">		<span class="keyword">switch</span>(month)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			System.out.println(<span class="string">&quot;spring&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">			System.out.println(<span class="string">&quot;summer&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">			System.out.println(<span class="string">&quot;autum&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">			System.out.println(<span class="string">&quot;winter&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line"><span class="comment">//	巧妙的方式减少冗余。</span></span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入2019年的month:&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> month1 = in.nextInt();</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入2019年的day:&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> day = in.nextInt();</span><br><span class="line">		<span class="keyword">int</span> sumdays = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">switch</span>(month1)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">			sumdays += <span class="number">30</span>; </span><br><span class="line">		<span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">			sumdays += <span class="number">31</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">			sumdays += <span class="number">30</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">			sumdays += <span class="number">31</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">			sumdays += <span class="number">31</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">			sumdays += <span class="number">30</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">			sumdays += <span class="number">31</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">			sumdays += <span class="number">30</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			sumdays += <span class="number">31</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			sumdays += <span class="number">28</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			sumdays += <span class="number">31</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			sumdays += day;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;2019年&quot;</span> + month1 + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;日&quot;</span> + sumdays);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//1.声明两个int型变量并赋值。判断两数之和，如果大于等于50，打印“hello world!”</span></span><br><span class="line">		System.out.println(<span class="string">&quot;请输入两个整数：&quot;</span>);</span><br><span class="line">		Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> a = in.nextInt();</span><br><span class="line">		<span class="keyword">int</span> b = in.nextInt();</span><br><span class="line">		<span class="keyword">if</span>((a + b) &gt;= <span class="number">50</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//2.编写程序两个double值。判断第一个数大于10.0,且第二个数小于20.0,打印两数之和。否则，打印两数的乘积；		</span></span><br><span class="line">		System.out.println(<span class="string">&quot;请输入两个double的值 ：&quot;</span>);</span><br><span class="line">		<span class="keyword">double</span> b1 = in.nextDouble();</span><br><span class="line">		<span class="keyword">double</span> b2 = in.nextDouble();</span><br><span class="line">		<span class="keyword">if</span>(b1 &gt; <span class="number">10.0</span> &amp;&amp; b2 &lt; <span class="number">20.0</span>)&#123;</span><br><span class="line">			System.out.println(b1 + b2);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(b1 * b2);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//3.我家狗五岁了 ，五岁的狗相当于人类多大呢？</span></span><br><span class="line">		<span class="comment">//其实，狗前两年每一年相当于人类的10.5岁,之后每增加一年就增加四岁</span></span><br><span class="line">		<span class="comment">//那么五岁的狗相当于人类的多少年龄33岁；</span></span><br><span class="line">		<span class="comment">//编写程序输入狗的年龄判断相当于人多少岁</span></span><br><span class="line">		System.out.println(<span class="string">&quot;请输入狗狗的年龄：&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> dogAge = in.nextInt();</span><br><span class="line">		<span class="keyword">if</span>(dogAge &gt;=<span class="number">0</span> &amp;&amp; dogAge &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;相当于人&quot;</span> + dogAge*<span class="number">10.5</span> +<span class="string">&quot;岁&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;相当于人&quot;</span> + ((dogAge-<span class="number">2</span>)*<span class="number">4</span>+<span class="number">21</span>) + <span class="string">&quot;岁&quot;</span>);</span><br><span class="line">			<span class="comment">//不加括号就连接加括号就不是连接而是运算</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//4.随机生成一个两位数的彩票，提示用户输入一个两位数，然后按照下面的规则判断用户是否能赢。		</span></span><br><span class="line">		System.out.println(<span class="string">&quot;请输入一个两位数数&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> aa = in.nextInt();</span><br><span class="line">		<span class="keyword">int</span> a1 = aa / <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">int</span> a2 = aa % <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">int</span> a3 = (<span class="keyword">int</span>)(Math.random()*<span class="number">90</span> + <span class="number">10</span>);</span><br><span class="line">		<span class="comment">//随机数Math.random()[0.0,1.0)</span></span><br><span class="line">		<span class="comment">//如何获取一个10-99的随机数</span></span><br><span class="line">		<span class="comment">//Math.random()*90 --&gt;[0.0-90.0)</span></span><br><span class="line">		<span class="comment">//Math.random()*90 + 10 --&gt;[10.0-100.0)</span></span><br><span class="line">		<span class="comment">//(int)(Math.random()*90 + 10) --&gt;[10-99]</span></span><br><span class="line">		<span class="comment">//强转之后前面的10.0还是10但是100.0是开区间没到100所以转到99</span></span><br><span class="line"><span class="comment">//	公式 ：[a,b] : (int)(Math.random() * (b - a + 1) + a)	</span></span><br><span class="line">		<span class="keyword">if</span>(a1 == a3 / <span class="number">10</span> &amp;&amp; a2 == a3 % <span class="number">10</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;奖励10000$&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a1 == a3 % <span class="number">10</span> &amp;&amp; a2 == a3 / <span class="number">10</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;奖励3000$&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a1 == a3 / <span class="number">10</span> || a2 == a3 % <span class="number">10</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;奖励1000$&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a1 == a3 % <span class="number">10</span> || a2 == a3 / <span class="number">10</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;奖励500$&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;彩票作废&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="chapter-3：-数组"><a href="#chapter-3：-数组" class="headerlink" title="#chapter 3： 数组"></a>#chapter 3： 数组</h1><h3 id="1-数组的概述"><a href="#1-数组的概述" class="headerlink" title="1. 数组的概述"></a>1. 数组的概述</h3><h4 id="1-1-数组的理解："><a href="#1-1-数组的理解：" class="headerlink" title="1.1 数组的理解："></a>1.1 数组的理解：</h4><p><font color="red">数组(Array)，是多个相同类型数据一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。</font></p>
<h4 id="1-2-数组相关的概念"><a href="#1-2-数组相关的概念" class="headerlink" title="1.2 数组相关的概念:"></a>1.2 数组相关的概念:</h4><ol>
<li>数组名</li>
<li>元素</li>
<li>角标、下标、索引</li>
<li>数组的长度：元素的个数</li>
</ol>
<h4 id="1-3-数组的特性"><a href="#1-3-数组的特性" class="headerlink" title="1.3 数组的特性"></a>1.3 数组的特性</h4><ol>
<li>数组是有序排列的</li>
<li>数组属于引用类型变量。数组元素既可以是基本数据类型，也可以是引用数据类型。</li>
<li>创建数组对象会在内存中开辟一整块连续的空间</li>
<li>数组的长度一旦确定，就不能修改了。</li>
</ol>
<h4 id="1-4-数组的分类："><a href="#1-4-数组的分类：" class="headerlink" title="1.4 数组的分类："></a>1.4 数组的分类：</h4><ol>
<li>安装维数分类：数组分为一维数组、二维数组、………..</li>
<li>安装数组元素分类：基本数据类型数组、引用数据类型数组。</li>
</ol>
<h3 id="2-一维数组的使用"><a href="#2-一维数组的使用" class="headerlink" title="2. 一维数组的使用"></a>2. 一维数组的使用</h3><h4 id="2-1-一维数组的声明与初始化"><a href="#2-1-一维数组的声明与初始化" class="headerlink" title="2.1 一维数组的声明与初始化"></a>2.1 一维数组的声明与初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">正确的方式：</span><br><span class="line">	<span class="keyword">int</span> num;<span class="comment">//声明</span></span><br><span class="line">		num = <span class="number">10</span>;<span class="comment">//初始化</span></span><br><span class="line">		<span class="keyword">int</span> id = <span class="number">1001</span>;<span class="comment">//声明 + 初始化</span></span><br><span class="line">		<span class="keyword">int</span>[] ids;<span class="comment">//声明</span></span><br><span class="line">		<span class="comment">//1.1 静态初始化:数组的初始化和数组元素的赋值操作同时进行</span></span><br><span class="line">		ids = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>&#125;;</span><br><span class="line">		<span class="comment">//1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行</span></span><br><span class="line">		String[] names = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">int</span>[] arr4 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//类型推断</span></span><br><span class="line"></span><br><span class="line">错误的方式：</span><br><span class="line"><span class="comment">//		int[] arr1 = new int[];</span></span><br><span class="line"><span class="comment">//		int[5] arr2 = new int[5];</span></span><br><span class="line"><span class="comment">//		int[] arr3 = new int[3]&#123;1,2,3&#125;;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-一维数组元素的引用-通过角标的方式调用。"><a href="#2-2-一维数组元素的引用-通过角标的方式调用。" class="headerlink" title="2.2  一维数组元素的引用:通过角标的方式调用。"></a>2.2  一维数组元素的引用:通过角标的方式调用。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组的角标（或索引从0开始的，到数组的长度-1结束。</span></span><br><span class="line">names[<span class="number">0</span>] = <span class="string">&quot;王铭&quot;</span>;</span><br><span class="line">names[<span class="number">1</span>] = <span class="string">&quot;王赫&quot;</span>;</span><br><span class="line">names[<span class="number">2</span>] = <span class="string">&quot;张学良&quot;</span>;</span><br><span class="line">names[<span class="number">3</span>] = <span class="string">&quot;孙居龙&quot;</span>;</span><br><span class="line">names[<span class="number">4</span>] = <span class="string">&quot;王宏志&quot;</span>;<span class="comment">//charAt(0)</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-数组的属性：length"><a href="#2-3-数组的属性：length" class="headerlink" title="2.3  数组的属性：length"></a>2.3  数组的属性：length</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(names.length);<span class="comment">//5</span></span><br><span class="line">System.out.println(ids.length);</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong><br><strong>数组一旦初始化，其长度就是确定的。arr.length</strong><br><strong>数组长度一旦确定，就不可修改。</strong></p>
<h4 id="2-4-一维数组的遍历"><a href="#2-4-一维数组的遍历" class="headerlink" title="2.4  一维数组的遍历"></a>2.4  一维数组的遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.length; i++)&#123;</span><br><span class="line">	System.out.println(names[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-一维数组元素的默认初始化值"><a href="#2-5-一维数组元素的默认初始化值" class="headerlink" title="2.5  一维数组元素的默认初始化值"></a>2.5  一维数组元素的默认初始化值</h4><ol>
<li>数组元素是整型: 0</li>
<li>数组元素是浮点型: 0.0</li>
<li>数组元素是char型： 0 或’/u0000’，而非’0’</li>
<li>数组元素是boolean型: false</li>
<li><strong>数组元素是引用类型: null</strong></li>
</ol>
<h4 id="2-6-一维数组的内存解析"><a href="#2-6-一维数组的内存解析" class="headerlink" title="2.6   一维数组的内存解析"></a>2.6   一维数组的内存解析</h4><p><img src="/images/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90.png"></p>
<h3 id="3-二维数组"><a href="#3-二维数组" class="headerlink" title="3.  二维数组"></a>3.  二维数组</h3><h4 id="3-1-如何理解二位数组"><a href="#3-1-如何理解二位数组" class="headerlink" title="3.1 如何理解二位数组"></a>3.1 如何理解二位数组</h4><p><strong>数组属于引用数据类型</strong></p>
<p><strong>数组元素也可以是引用数据类型</strong></p>
<p><font color="red">一个一维数组A的元素如果还是一个一维数组类型的，则，此数组A称为二维数组</font></p>
<h4 id="3-2-二维数组的声明与初始化"><a href="#3-2-二维数组的声明与初始化" class="headerlink" title="3.2  二维数组的声明与初始化"></a>3.2  二维数组的声明与初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">正确的方式:</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//一维数组</span></span><br><span class="line">        <span class="comment">//静态初始化</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//动态初始化</span></span><br><span class="line">        String[][] arr2 = <span class="keyword">new</span> String[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//动态初始化2</span></span><br><span class="line">        String[][] arr3 = <span class="keyword">new</span> String[<span class="number">3</span>][];</span><br><span class="line">        <span class="comment">//也是正确的写法</span></span><br><span class="line">        <span class="keyword">int</span>[] arr4[] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;<span class="comment">//[3][4]</span></span><br><span class="line">        <span class="keyword">int</span>[] arr5[] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;<span class="comment">//类型推断</span></span><br><span class="line">错误的方式:	</span><br><span class="line">		String[][] arr4 = <span class="keyword">new</span> String[][<span class="number">4</span>];</span><br><span class="line">		String[<span class="number">4</span>][<span class="number">3</span>] arr5 = <span class="keyword">new</span> String[][];</span><br><span class="line">		<span class="keyword">int</span>[][] arr6 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">3</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-如何调用二维数组元素"><a href="#3-3-如何调用二维数组元素" class="headerlink" title="3.3 如何调用二维数组元素:"></a>3.3 如何调用二维数组元素:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(arr1[<span class="number">0</span>][<span class="number">1</span>]);<span class="comment">//2</span></span><br><span class="line">System.out.println(arr2[<span class="number">1</span>][<span class="number">1</span>]);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">arr3[<span class="number">1</span>] = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br><span class="line">System.out.println(arr3[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">System.out.println(arr3[<span class="number">0</span>]);<span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h4 id="3-4-二维数组的属性"><a href="#3-4-二维数组的属性" class="headerlink" title="3.4 二维数组的属性:"></a>3.4 二维数组的属性:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(arr4.length);<span class="comment">//3</span></span><br><span class="line">System.out.println(arr4[<span class="number">0</span>].length);<span class="comment">//3</span></span><br><span class="line">System.out.println(arr4[<span class="number">1</span>].length);<span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<h4 id="3-5-遍历二维数组元素"><a href="#3-5-遍历二维数组元素" class="headerlink" title="3.5 遍历二维数组元素"></a>3.5 遍历二维数组元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr4.lenght; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr4[i].length; i++)&#123;</span><br><span class="line">		System.out.print(arr4[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-6-二维数组元素的默认初始化值"><a href="#3-6-二维数组元素的默认初始化值" class="headerlink" title="3.6 二维数组元素的默认初始化值"></a>3.6 二维数组元素的默认初始化值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* 	规定：二维数组分为外层数组的元素，内层数组的元素</span><br><span class="line">* 		<span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line">* 		外层元素：arr[<span class="number">0</span>],arr[<span class="number">1</span>]等</span><br><span class="line">* 		内层元素：arr[<span class="number">0</span>][<span class="number">0</span>],arr[<span class="number">1</span>][<span class="number">2</span>]等</span><br><span class="line">* </span><br><span class="line">*   ⑤ 数组元素的默认初始化值 </span><br><span class="line">*   针对于初始化方式一：比如：<span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line">*      外层元素的初始化值为：地址值</span><br><span class="line">*      内层元素的初始化值为：与一维数组初始化情况相同</span><br><span class="line">*      </span><br><span class="line">*   针对于初始化方式二：比如：<span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][];</span><br><span class="line">*   	外层元素的初始化值为：<span class="keyword">null</span></span><br><span class="line">*      内层元素的初始化值为：不能调用，否则报错。</span><br></pre></td></tr></table></figure>

<h4 id="3-7-二维数组的内存结构（重点）"><a href="#3-7-二维数组的内存结构（重点）" class="headerlink" title="3.7  二维数组的内存结构（重点）"></a>3.7  二维数组的内存结构（重点）</h4><p><img src="/images/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90.png"></p>
<h3 id="4-数组的常见算法："><a href="#4-数组的常见算法：" class="headerlink" title="4. 数组的常见算法："></a>4. 数组的常见算法：</h3><h4 id="4-1-数组的创建与元素赋值"><a href="#4-1-数组的创建与元素赋值" class="headerlink" title="4.1 数组的创建与元素赋值:"></a>4.1 数组的创建与元素赋值:</h4><p>杨辉三角（二维数组）、回形数（二维数组）、6个数，1-30之间随机生成且不重复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//使用二维数组打印一个10行杨辉三角</span></span><br><span class="line">        <span class="comment">//1.每一行有1个元素，第n行有n个元素</span></span><br><span class="line">        <span class="comment">//2.每一行的第一个元素和最后一个元素都是1</span></span><br><span class="line">        <span class="comment">//3.从第三行开始，对于非第一个元素和最后一个元素的元素。即</span></span><br><span class="line">        <span class="comment">//yanghui[i][j] = yanghui[i-1][j-1] + yanghui[i-1][j];</span></span><br><span class="line">        <span class="comment">//1.声明初始化数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] yangHui = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][];</span><br><span class="line">        <span class="comment">//2.给数组元素赋值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; yangHui.length; i++)&#123;</span><br><span class="line">            yangHui[i] = <span class="keyword">new</span> <span class="keyword">int</span>[i + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//2.1给首末元素赋值</span></span><br><span class="line">            yangHui[i][<span class="number">0</span>] = yangHui[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//2.2给每行的非首末元素赋值</span></span><br><span class="line"><span class="comment">//			if(i &gt; 1)&#123;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; yangHui[i].length - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                yangHui[i][j] = yangHui[i-<span class="number">1</span>][j-<span class="number">1</span>] + yangHui[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line">        &#125;<span class="comment">//这块很重要容易忘记</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6个数，1-30之间随机生成且不重复。</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">			arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">30</span> + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[i] == arr[j])&#123;</span><br><span class="line">					i--;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;  </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">			System.out.println(arr[i]);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-针对于数值型的数组："><a href="#4-2-针对于数值型的数组：" class="headerlink" title="4.2  针对于数值型的数组："></a>4.2  针对于数值型的数组：</h4><p>最大值、最小值、总和、平均数等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.nn.ff;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 算法的考查，求数值型数组中元素的最大值、最小值、平均数、总和等</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 定义一个int 型的一维数组，包含10个元素，分别赋一些随机数，</span></span><br><span class="line"><span class="comment"> * 然后求出所有元素的最大值、最小值、求和、平均值，并输出出来。</span></span><br><span class="line"><span class="comment"> * 要求：所有随机数都是两位数</span></span><br><span class="line"><span class="comment"> * [10-99]</span></span><br><span class="line"><span class="comment"> * 公式：[a,b](int)(Math.random * (b - a + 1) + a)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest4</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">			arr[i] = (<span class="keyword">int</span>)(Math.random() * (<span class="number">99</span> - <span class="number">10</span> + <span class="number">1</span>) + <span class="number">10</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> average = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> min = arr[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">			sum += arr[i];</span><br><span class="line">			<span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">				max = arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(arr[i] &lt; min)&#123;</span><br><span class="line">				min = arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.print(arr[i] + <span class="string">&quot;/t&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		average = sum / <span class="number">10</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;和为：&quot;</span> + sum);</span><br><span class="line">		System.out.println(<span class="string">&quot;平均数为：&quot;</span> + average);</span><br><span class="line">		System.out.println(<span class="string">&quot;最大值为：&quot;</span> + max + <span class="string">&quot; 最小值为：&quot;</span> + min);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-数组的赋值与复制"><a href="#4-3-数组的赋值与复制" class="headerlink" title="4.3 数组的赋值与复制"></a>4.3 数组的赋值与复制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array1,array2;</span><br><span class="line">array1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="4-3-1-赋值："><a href="#4-3-1-赋值：" class="headerlink" title="4.3.1 赋值："></a>4.3.1 赋值：</h5><p>array2 = array1;<br><strong>如何理解：将array1保存的数组的地址值赋给了array2，使得array1和array2共同指向堆空间中的同一个数组实体。</strong></p>
<p><img src="/images/%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC%E5%9B%BE%E8%A7%A3.png"></p>
<h5 id="4-3-2-复制："><a href="#4-3-2-复制：" class="headerlink" title="4.3.2 复制："></a>4.3.2 复制：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array2 = <span class="keyword">new</span> <span class="keyword">int</span>[array1.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array2.length;i++)&#123;</span><br><span class="line">array2[i] = array1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6%E5%9B%BE%E8%A7%A3.png"></p>
<p><strong>如何理解：我们通过new的方式，给array2在堆空间中新开辟了数组的空间。将array1数组中的元素值一个一个的赋值到array2数组中。</strong></p>
<h4 id="4-4-数组元素的反转"><a href="#4-4-数组元素的反转" class="headerlink" title="4.4 数组元素的反转"></a>4.4 数组元素的反转</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	&#x2F;&#x2F;方法一：</span><br><span class="line">&#x2F;&#x2F;		for(int i &#x3D; 0;i &lt; arr.length &#x2F; 2;i++)&#123;</span><br><span class="line">&#x2F;&#x2F;			String temp &#x3D; arr[i];</span><br><span class="line">&#x2F;&#x2F;			arr[i] &#x3D; arr[arr.length - i -1];</span><br><span class="line">&#x2F;&#x2F;			arr[arr.length - i -1] &#x3D; temp;</span><br><span class="line">&#x2F;&#x2F;		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;方法二：</span><br><span class="line">&#x2F;&#x2F;		for(int i &#x3D; 0,j &#x3D; arr.length - 1;i &lt; j;i++,j--)&#123;</span><br><span class="line">&#x2F;&#x2F;			String temp &#x3D; arr[i];</span><br><span class="line">&#x2F;&#x2F;			arr[i] &#x3D; arr[j];</span><br><span class="line">&#x2F;&#x2F;			arr[j] &#x3D; temp;</span><br><span class="line">&#x2F;&#x2F;		&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-数组中指定元素的查找：搜索、检索"><a href="#4-5-数组中指定元素的查找：搜索、检索" class="headerlink" title="4.5 数组中指定元素的查找：搜索、检索"></a>4.5 数组中指定元素的查找：搜索、检索</h4><h5 id="5-1-线性查找："><a href="#5-1-线性查找：" class="headerlink" title="5.1 线性查找："></a>5.1 线性查找：</h5><p>实现思路：通过遍历的方式，一个一个的数据进行比较、查找。<br>适用性：具有普遍适用性。</p>
<h5 id="5-2-二分法查找："><a href="#5-2-二分法查找：" class="headerlink" title="5.2 二分法查找："></a>5.2 二分法查找：</h5><p>实现思路：每次比较中间值，折半的方式检索。<br><strong>适用性：（前提：数组必须有序）</strong></p>
<h4 id="4-6-数组中的排序算法"><a href="#4-6-数组中的排序算法" class="headerlink" title="4.6 数组中的排序算法"></a>4.6 数组中的排序算法</h4><p><img src="/images/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png"></p>
<h5 id="4-6-1-手写冒泡排序"><a href="#4-6-1-手写冒泡排序" class="headerlink" title="4.6.1 手写冒泡排序"></a>4.6.1 手写冒泡排序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int [] arr &#x3D; new int[]&#123;45,56,89,78,13,21&#125;;</span><br><span class="line">for(int i &#x3D; 0; i &lt; arr.length - 1; i++)&#123;</span><br><span class="line">	for(int j &#x3D; 0; j &lt; arr.length - i -1; j++)&#123;</span><br><span class="line">		if(arr[j] &gt; arr[j+1])&#123;</span><br><span class="line">			int temp &#x3D; arr[j];</span><br><span class="line">			arr[j] &#x3D; arr[j+1];</span><br><span class="line">			arr[j+1] &#x3D; temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-Arrays工具类的使用（重点）"><a href="#5-Arrays工具类的使用（重点）" class="headerlink" title="5 . Arrays工具类的使用（重点）"></a>5 . Arrays工具类的使用<font color="red">（重点）</font></h3><h4 id="5-1-理解："><a href="#5-1-理解：" class="headerlink" title="5.1 理解："></a>5.1 理解：</h4><ol>
<li>定义在java.util包下 。</li>
<li>Arrays:提供了很多操作数组的方法。</li>
</ol>
<h4 id="5-2-使用"><a href="#5-2-使用" class="headerlink" title="5.2 使用:"></a>5.2 使用:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.boolean equals(int[] a,int[] b):判断两个数组是否相等。</span><br><span class="line">        int[] arr1 &#x3D; new int[]&#123;1, 2, 3, 4&#125;;</span><br><span class="line">        int[] arr2 &#x3D; new int[]&#123;1, 3, 2, 4&#125;;</span><br><span class="line">        boolean isEquals &#x3D; Arrays.equals(arr1, arr2);</span><br><span class="line">        System.out.println(isEquals);&#x2F;&#x2F;false</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;2.String toString(int[] a):输出数组信息。</span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;3.void fill(int[] a,int val):将指定值填充到数组之中。</span><br><span class="line">        Arrays.fill(arr1, 10);</span><br><span class="line">        System.out.println(Arrays.toString(arr1));&#x2F;&#x2F;[10, 10, 10, 10]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;4.void sort(int[] a):对数组进行排序。</span><br><span class="line">        Arrays.sort(arr2);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;5.int binarySearch(int[] a,int key)</span><br><span class="line">        int[] arr3 &#x3D; new int[]&#123;-98, -34, 2, 34, 54, 66, 79, 105, 210, 333&#125;;</span><br><span class="line">        int index &#x3D; Arrays.binarySearch(arr3, 210);</span><br><span class="line">        if (index &gt;&#x3D; 0) &#123;</span><br><span class="line">            System.out.println(index);&#x2F;&#x2F;8</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;未找到&quot;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-数组的常见异常"><a href="#6-数组的常见异常" class="headerlink" title="6. 数组的常见异常:"></a>6. 数组的常见异常:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1.数组角标越界异常：ArrayIndexOutOfBoundsException</span><br><span class="line"></span><br><span class="line">		int[] arr &#x3D; new int[]&#123;1,2,3,4,5&#125;;</span><br><span class="line">		</span><br><span class="line">&#x2F;&#x2F;		for(int i &#x3D; 0;i &lt;&#x3D; arr.length;i++)&#123;</span><br><span class="line">&#x2F;&#x2F;			System.out.println(arr[i]);</span><br><span class="line">&#x2F;&#x2F;		&#125;</span><br><span class="line">		</span><br><span class="line">&#x2F;&#x2F;		System.out.println(arr[-2]);</span><br><span class="line">		</span><br><span class="line">&#x2F;&#x2F;		System.out.println(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">2.空指针异常：NullPointerException</span><br><span class="line">	&#x2F;&#x2F;情况一：</span><br><span class="line">&#x2F;&#x2F;		int[] arr1 &#x3D; new int[]&#123;1,2,3&#125;;</span><br><span class="line">&#x2F;&#x2F;		arr1 &#x3D; null;</span><br><span class="line">&#x2F;&#x2F;		System.out.println(arr1[0]);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;情况二：</span><br><span class="line">&#x2F;&#x2F;		int[][] arr2 &#x3D; new int[4][];</span><br><span class="line">&#x2F;&#x2F;		System.out.println(arr2[0][0]);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;情况：</span><br><span class="line">		String[] arr3 &#x3D; new String[]&#123;&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;&#125;;</span><br><span class="line">		arr3[0] &#x3D; null;</span><br><span class="line">		System.out.println(arr3[0].toString());</span><br><span class="line"></span><br><span class="line">小知识：一旦程序出现异常，未处理时，就终止执行。</span><br></pre></td></tr></table></figure>





<h1 id="chapter4：-面向对象上-重点"><a href="#chapter4：-面向对象上-重点" class="headerlink" title="#chapter4： 面向对象上(重点)"></a>#chapter4： 面向对象上(重点)</h1><h3 id="1-类与对象"><a href="#1-类与对象" class="headerlink" title="1. 类与对象"></a>1. 类与对象</h3><h4 id="1-1-面向对象学习的三条主线"><a href="#1-1-面向对象学习的三条主线" class="headerlink" title="1.1 面向对象学习的三条主线:"></a>1.1 面向对象学习的三条主线:</h4><ol>
<li>Java类及类的成员：属性、方法、构造器、；代码块、内部类</li>
<li>面向对象的大特征：<strong>封装性</strong>、<strong>继承性</strong>、<strong>多态性</strong>、(抽象性)</li>
<li>其他关键字：this、super、static、final、abstract、interface、package、import等</li>
</ol>
<h4 id="1-2-面向对象与面向过程-理解"><a href="#1-2-面向对象与面向过程-理解" class="headerlink" title="1.2 面向对象与面向过程(理解):"></a>1.2 面向对象与面向过程(理解):</h4><ol>
<li>面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。</li>
<li>面向对象：强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</li>
<li>举例对比：人把大象装进冰箱。</li>
</ol>
<h4 id="1-3-完成一个项目（或功能）的思路"><a href="#1-3-完成一个项目（或功能）的思路" class="headerlink" title="1.3 完成一个项目（或功能）的思路:"></a>1.3 完成一个项目（或功能）的思路:</h4><p><img src="/images/%E5%AE%8C%E6%88%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%9D%E8%B7%AF.png"></p>
<h4 id="1-4-面向对象中两个重要的概念"><a href="#1-4-面向对象中两个重要的概念" class="headerlink" title="1.4 面向对象中两个重要的概念:"></a>1.4 面向对象中两个重要的概念:</h4><p><strong>类：对一类事物的描述，是抽象的、概念上的定义</strong></p>
<p><strong>对象:是实际存在的该类事物的每个个体，因而也称为实例(instance)</strong></p>
<ol>
<li>面向对象程序设计的重点在于设计</li>
<li>设计类，就是设计类的成员。</li>
</ol>
<h4 id="1-5-面向对象思想落地实现的规则一"><a href="#1-5-面向对象思想落地实现的规则一" class="headerlink" title="1.5 面向对象思想落地实现的规则一"></a>1.5 面向对象思想落地实现的规则一</h4><ol>
<li>创建类，设计类的成员</li>
<li>创建类的对象 </li>
<li>通过”对象.属性”或”对象.方法”调用对象的结构</li>
</ol>
<h4 id="1-6-对象的创建于对象的内存解析"><a href="#1-6-对象的创建于对象的内存解析" class="headerlink" title="1.6 对象的创建于对象的内存解析"></a>1.6 对象的创建于对象的内存解析</h4><h5 id="1-6-1-典型代码："><a href="#1-6-1-典型代码：" class="headerlink" title="1.6.1 典型代码："></a>1.6.1 典型代码：</h5><p>Person p1 = new Person();<br>Person p2 = new Person();<br>Person p3 = p1;//没有新创建一个对象，共用一个堆空间中的对象实体。</p>
<h5 id="1-6-2-说明："><a href="#1-6-2-说明：" class="headerlink" title="1.6.2 说明："></a>1.6.2 说明：</h5><p>如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非<strong>static</strong>的）</p>
<p>意味着: 如果我们修改一个对象的属性a,则不影响另外一个对象的属性a的值。</p>
<h5 id="1-6-3-内存解析："><a href="#1-6-3-内存解析：" class="headerlink" title="1.6.3 内存解析："></a>1.6.3 内存解析：</h5><p><img src="/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%901.png"></p>
<p><img src="/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%902.png"></p>
<h4 id="1-7-匿名对象："><a href="#1-7-匿名对象：" class="headerlink" title="1.7 匿名对象："></a>1.7 匿名对象：</h4><p><strong>我们创建的对象，没有显示的赋值给一个变量名。即为匿名对象</strong></p>
<h5 id="1-7-1-特点："><a href="#1-7-1-特点：" class="headerlink" title="1.7.1 特点："></a>1.7.1 特点：</h5><p>匿名对象只能调用一次</p>
<h5 id="1-7-2-举例"><a href="#1-7-2-举例" class="headerlink" title="1.7.2 举例:"></a>1.7.2 举例:</h5><p>new Phone().sendEmail();<br>new Phone().playGame();<br>new Phone().price = 1999;<br>new Phone().showPrice();//0.0</p>
<h5 id="1-7-3-应用场景"><a href="#1-7-3-应用场景" class="headerlink" title="1.7.3 应用场景:"></a>1.7.3 应用场景:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PhoneMall mall &#x3D; new PhoneMall();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;匿名对象的使用</span><br><span class="line">mall.show(new Phone());</span><br><span class="line">其中，</span><br><span class="line">class PhoneMall&#123;</span><br><span class="line">	public void show(Phone phone)&#123;</span><br><span class="line">		phone.sendEmail();</span><br><span class="line">		phone.playGame();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-8-理解“万事万物皆对象”"><a href="#1-8-理解“万事万物皆对象”" class="headerlink" title="1.8 理解“万事万物皆对象”"></a>1.8 理解“万事万物皆对象”</h4><ol>
<li>在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构  如:Scanner,String等,  文件：File,   网络资源：URL。</li>
<li>涉及到Java语言与前端Html、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。</li>
</ol>
<h4 id="1-9-JVM内存结构"><a href="#1-9-JVM内存结构" class="headerlink" title="1.9 JVM内存结构"></a>1.9 JVM内存结构</h4><p>编译完源程序以后，生成一个或多个字节码文件。<br>我们使用JVM中的类的加载器和解释器对生成的字节码文件进行解释运行。意味着，需要将字节码文件对应的类加载到内存中，涉及到内存解析。</p>
<p><img src="/images/JVM%E5%9B%BE%E8%A7%A3.png"></p>
<p>《JVM规范》</p>
<p>虚拟机栈，即为平时提到的栈结构。<font color="red">我们将局部变量存储在栈结构中   <br>堆，我们将new出来的结构（比如：数组、对象）加载在堆空间中。补充：对象的属性（非static的）加载在堆空间中。<br>方法区：类的加载信息、常量池、静态域</font></p>
<h3 id="2-类的结构之一：属性"><a href="#2-类的结构之一：属性" class="headerlink" title="2. 类的结构之一：属性"></a>2. 类的结构之一：属性</h3><p><strong>类的设计中，两个重要结构之一：属性</strong></p>
<p>对比：属性  vs  局部变量</p>
<p><font color="red">相同点：</font></p>
<ol>
<li>定义变量的格式：数据类型   变量名 = 变量值</li>
<li>先声明后使用</li>
<li>变量都有其对应的作用域</li>
</ol>
<p><font color="red">不同点：</font></p>
<ol>
<li>在类中声明的位置不同<ul>
<li>属性：直接定义在类的一对{}中</li>
<li>局部变量：定义在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</li>
</ul>
</li>
<li>关于权限修饰符的不同<ul>
<li>属性：可以在声明属性时，指明其权限，使用权限修饰符。常用的权限修饰符：private、 public、缺省、protected —-&gt; 封装性</li>
<li>局部变量: 不可以使用权限修饰符。</li>
</ul>
</li>
<li>默认初始化的情况:<ul>
<li>属性：类的属性，根据其类型，都默认初始化值。</li>
<li>整型(byte,short,int,long : 0)</li>
<li>浮点型(float,double: 0.0)</li>
<li>字符型(char : 0（或’/u0000’）)</li>
<li>布尔型(boolean : false)</li>
<li>引用数据类型（类，数组，接口 ： null）</li>
<li>局部变量：没有默认初始化值。</li>
<li><font color="red">意味着，我们调用局部变量之前需要给局部变量显式的赋值。特别地：形参在调用时，我们赋值即可。</font></li>
</ul>
</li>
<li>在内存中的位置：<ul>
<li>属性：加载到堆空间中（非static）</li>
<li>局部变量：加载到栈空间中。</li>
</ul>
</li>
</ol>
<h3 id="3-类的结构之二：方法"><a href="#3-类的结构之二：方法" class="headerlink" title="3. 类的结构之二：方法"></a>3. 类的结构之二：方法</h3><p><strong>类的设计中，两个重要结构之二：方法</strong></p>
<h4 id="3-1-方法的简单介绍"><a href="#3-1-方法的简单介绍" class="headerlink" title="3.1 方法的简单介绍"></a>3.1 方法的简单介绍</h4><p><font color="red"><strong>方法：描述类应该具备的功能。</strong></font></p>
<h5 id="3-1-1-方法的声明"><a href="#3-1-1-方法的声明" class="headerlink" title="3.1.1 方法的声明:"></a>3.1.1 方法的声明:</h5><p>权限修饰符    <strong>返回值类型</strong>    方法名(<strong>形参列表</strong>){</p>
<p>​                方法体</p>
<p>}</p>
<p>注意：static、final、abstract 来修饰的方法，后面再讲。</p>
<h5 id="3-1-2-说明"><a href="#3-1-2-说明" class="headerlink" title="3.1.2 说明:"></a>3.1.2 说明:</h5><ol>
<li>关于权限修饰符：默认方法的权限修饰符先都使用public。Java规定的4中权限修饰符:private/public/缺省/protected — &gt;封装性</li>
<li>返回值类型：返回值  VS 没返回值<ol>
<li>如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用“return 数据”进行返回指定类型的变量或常量。</li>
<li>如果方法没有返回值，则方法声明时，使用void来表示。通常，没返回值的方法中，就不需要return。但是，如果使用的话，只能”return;”表示此方法结束的意思。</li>
<li>我们定义的方法需不需要返回值？<ol>
<li>根据题目要求来</li>
<li>凭经验：具体问题具体分析</li>
</ol>
</li>
</ol>
</li>
<li>方法名：属于标识符，需要遵循标识符的规范。应该做到见名知意。</li>
<li>形参列表：方法中可以声明0个或多个形参。<ol>
<li>格式：数据类型1  形参1，数据类型2 形参2，…..</li>
<li>我们定义方法时，该不该定义形参?<ol>
<li>根据题目要求来</li>
<li>凭经验：具体问题具体分析</li>
</ol>
</li>
</ol>
</li>
<li>方法体：方法功能的体现。</li>
</ol>
<h5 id="3-1-4-方法的使用中，可以调用当前类的属性或方法"><a href="#3-1-4-方法的使用中，可以调用当前类的属性或方法" class="headerlink" title="3.1.4 方法的使用中，可以调用当前类的属性或方法"></a>3.1.4 方法的使用中，可以调用当前类的属性或方法</h5><p>特殊的：方法A中调用方法A：递归方法。</p>
<p>方法中，不能定义方法。</p>
<h4 id="3-2-关键字：return"><a href="#3-2-关键字：return" class="headerlink" title="3.2 关键字：return"></a>3.2 关键字：return</h4><ol>
<li>使用范围：使用在方法体中。</li>
<li>作用：<ol>
<li>结束方法</li>
<li>针对于返回值类型的方法，使用“return  数据”方法返回所要的数据</li>
</ol>
</li>
<li>注意点：return关键字后面不能再声明执行语句。</li>
</ol>
<h4 id="3-3-方法的重载"><a href="#3-3-方法的重载" class="headerlink" title="3.3 方法的重载"></a>3.3 方法的重载</h4><h5 id="3-3-1-方法的重载的概念"><a href="#3-3-1-方法的重载的概念" class="headerlink" title="3.3.1 方法的重载的概念"></a>3.3.1 方法的重载的概念</h5><p><font color="red">定义：在同一个类中，允许存在一个以上的同名方法，只要他们的参数列表中的参数个数不是相同的或参数类型不是相同的即可</font></p>
<p><strong>总结：“两同一不同”：同一个类、相同的方法名、参数列表不同：参数个数不同， 参数类型不同</strong></p>
<h5 id="3-3-2-举例"><a href="#3-3-2-举例" class="headerlink" title="3.3.2 举例"></a>3.3.2 举例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;如下的4个方法构成了重载</span><br><span class="line">	public void getSum(int i,int j)&#123;</span><br><span class="line">		System.out.println(&quot;1&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void getSum(double d1,double d2)&#123;</span><br><span class="line">		System.out.println(&quot;2&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void getSum(String s ,int i)&#123;</span><br><span class="line">		System.out.println(&quot;3&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void getSum(int i,String s)&#123;</span><br><span class="line">		System.out.println(&quot;4&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<h5 id="3-3-3-（面试题）方法的重载与重写的区别？"><a href="#3-3-3-（面试题）方法的重载与重写的区别？" class="headerlink" title="3.3.3 （面试题）方法的重载与重写的区别？"></a>3.3.3 （面试题）方法的重载与重写的区别？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方法的重写：</span><br><span class="line">在Java程序中，类的继承关系可以产生一个子类，子类继承父类，它具备了父类所有的特征，继承了父类所有的方法和变量。</span><br><span class="line"></span><br><span class="line">子类可以定义新的特征，当子类需要修改父类的一些方法进行扩展，增大功能，程序设计者常常把这样的一种操作方法称为重写，也叫称为覆写或覆盖。</span><br><span class="line">方法的重载：</span><br><span class="line">在同一个类中，允许存在一个以上的同名方法，只要他们的参数列表中的参数个数不是相同的或参数类型不是相同的即可</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-4-可变形参的方法"><a href="#3-4-可变形参的方法" class="headerlink" title="3.4 可变形参的方法"></a>3.4 可变形参的方法</h4><h5 id="3-4-1-使用说明："><a href="#3-4-1-使用说明：" class="headerlink" title="3.4.1 使用说明："></a>3.4.1 使用说明：</h5><ol>
<li>jdk 5.0新增的内容</li>
<li>具体使用：<ol>
<li>可变个数形参的格式：数据类型 … 变量名</li>
<li>当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，。。。</li>
<li>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</li>
<li>可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。</li>
<li>可变个数形参在方法的形参中，必须声明在末尾</li>
<li>可变个数形参在方法的形参中,最多只能声明一个可变形参。</li>
</ol>
</li>
</ol>
<h5 id="3-4-2-举例说明："><a href="#3-4-2-举例说明：" class="headerlink" title="3.4.2 举例说明："></a>3.4.2 举例说明：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">	public void show(int i)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void show(String s)&#123;</span><br><span class="line">		System.out.println(&quot;show(String)&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void show(String ... strs)&#123;</span><br><span class="line">		System.out.println(&quot;show(String ... strs)&quot;);</span><br><span class="line">		</span><br><span class="line">		for(int i &#x3D; 0;i &lt; strs.length;i++)&#123;</span><br><span class="line">			System.out.println(strs[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;不能与上一个方法同时存在</span><br><span class="line">&#x2F;&#x2F;	public void show(String[] strs)&#123;</span><br><span class="line">&#x2F;&#x2F;		</span><br><span class="line">&#x2F;&#x2F;	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">调用时：</span><br><span class="line">		test.show(&quot;hello&quot;);</span><br><span class="line">		test.show(&quot;hello&quot;,&quot;world&quot;);</span><br><span class="line">		test.show();</span><br><span class="line">		</span><br><span class="line">		test.show(new String[]&#123;&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="3-5-java的值传递机制"><a href="#3-5-java的值传递机制" class="headerlink" title="3.5 java的值传递机制"></a>3.5 java的值传递机制</h4><h5 id="3-5-1-针对于方法内变量的赋值举例："><a href="#3-5-1-针对于方法内变量的赋值举例：" class="headerlink" title="3.5.1 针对于方法内变量的赋值举例："></a>3.5.1 针对于方法内变量的赋值举例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;***********基本数据类型：****************&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n = m;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line"></span><br><span class="line">n = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;***********引用数据类型：****************&quot;</span>);</span><br><span class="line"></span><br><span class="line">Order o1 = <span class="keyword">new</span> Order();</span><br><span class="line">o1.orderId = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line">Order o2 = o1;<span class="comment">//赋值以后，o1和o2的地址值相同，都指向了堆空间中同一个对象实体。</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;o1.orderId = &quot;</span> + o1.orderId + <span class="string">&quot;,o2.orderId = &quot;</span> +o2.orderId);</span><br><span class="line"></span><br><span class="line">o2.orderId = <span class="number">1002</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;o1.orderId = &quot;</span> + o1.orderId + <span class="string">&quot;,o2.orderId = &quot;</span> +o2.orderId);</span><br></pre></td></tr></table></figure>

<p><strong>规则：</strong></p>
<ol>
<li><strong>如果变量是基本数据类型，此时赋值的是变量所保存的数据值。</strong></li>
<li><strong>如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</strong></li>
</ol>
<h5 id="3-5-2-针对于方法的参数概念"><a href="#3-5-2-针对于方法的参数概念" class="headerlink" title="3.5.2 针对于方法的参数概念"></a>3.5.2 针对于方法的参数概念</h5><p>​    形参：方法定义时，声明的小括号内的参数</p>
<p>​    实参：方法调用时，实际传递给形参的数据</p>
<h5 id="3-5-3-java中参数传递机制：值传递"><a href="#3-5-3-java中参数传递机制：值传递" class="headerlink" title="3.5.3 java中参数传递机制：值传递"></a>3.5.3 java中参数传递机制：值传递</h5><p>规则：</p>
<ul>
<li>如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。</li>
<li>如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。</li>
</ul>
<h5 id="3-5-4-典型例题与内存解析："><a href="#3-5-4-典型例题与内存解析：" class="headerlink" title="3.5.4 典型例题与内存解析："></a>3.5.4 典型例题与内存解析：</h5><p><img src="/images/%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%921.png"></p>
<p><img src="/images/%E6%95%B0%E5%80%BC%E4%BC%A0%E9%80%922.png"></p>
<h4 id="3-6-递归方法"><a href="#3-6-递归方法" class="headerlink" title="3.6 递归方法"></a>3.6 递归方法</h4><h5 id="3-6-1-递归的定义："><a href="#3-6-1-递归的定义：" class="headerlink" title="3.6.1 递归的定义："></a>3.6.1 递归的定义：</h5><p><font color="red"><strong>递归方法：一个方法体内调用它自身。</strong></font></p>
<h5 id="3-6-2-如何理解递归方法？"><a href="#3-6-2-如何理解递归方法？" class="headerlink" title="3.6.2 如何理解递归方法？"></a>3.6.2 如何理解递归方法？</h5><ol>
<li>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。</li>
<li>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。</li>
</ol>
<h5 id="3-6-3-举例："><a href="#3-6-3-举例：" class="headerlink" title="3.6.3 举例："></a>3.6.3 举例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1：计算1-n之间所自然数的和</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> n + getSum(n - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 例2：计算1-n之间所自然数的乘积:n!</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> n * getSum1(n - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//例3：已知一个数列：f(0) = 1,f(1) = 4,f(n+2)=2*f(n+1) + f(n),</span></span><br><span class="line">	<span class="comment">//其中n是大于0的整数，求f(10)的值。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//			return f(n + 2) - 2 * f(n + 1);</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>*f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>





<h3 id="4-面向对象的特征一：封装性"><a href="#4-面向对象的特征一：封装性" class="headerlink" title="4. 面向对象的特征一：封装性"></a>4. 面向对象的特征一：封装性</h3><p><strong>面向对象的特征一：封装与隐藏</strong></p>
<h4 id="4-1-为什么要引入封装性？"><a href="#4-1-为什么要引入封装性？" class="headerlink" title="4.1 为什么要引入封装性？"></a>4.1 为什么要引入封装性？</h4><p>我们在程序设计的时候会追求“高内聚，低耦合”</p>
<ol>
<li>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；</li>
<li>低耦合：仅对外暴露少量的方法用于使用</li>
</ol>
<p><strong>隐藏对象内部的复杂性，只对外公开简单的接口。便于外部调用，从而提高系统的可扩展性、可维护性。通俗的说，<font color="red">把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想</font></strong></p>
<h4 id="4-2-问题引入"><a href="#4-2-问题引入" class="headerlink" title="4.2 问题引入"></a>4.2 问题引入</h4><p>当我们创建一个类的对象以后，我们可以通过”对象.属性”的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setLegs()同时，我们需要避免用户再使用”对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private).<br>  –&gt;此时，针对于属性就体现了封装性。</p>
<h4 id="4-3-封装性思想的代码体现"><a href="#4-3-封装性思想的代码体现" class="headerlink" title="4.3 封装性思想的代码体现"></a>4.3 封装性思想的代码体现</h4><p>体现一:将类的属性xxx私有化(private),同时，提供公共的（public）方法来获取(getXxx)和设置（setXxx）此属性的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> radius)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>体现二：不对外暴露的私有方法</p>
<p>体现三：单例模式(将构造器私有化)</p>
<p><img src="/images/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F1.png"></p>
<p><img src="/images/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F2.png"></p>
<p><img src="/images/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F3.png"></p>
<p><img src="/images/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F4.png"></p>
<p><img src="/images/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F5.png"></p>
<p>体现四：如果不希望类在包外被调用，可以将类设置为缺省的。</p>
<h4 id="4-4-Java规定的四种权限修饰符"><a href="#4-4-Java规定的四种权限修饰符" class="headerlink" title="4.4 Java规定的四种权限修饰符"></a>4.4 Java规定的四种权限修饰符</h4><h5 id="4-4-1-权限从小到大顺序为：private-lt-缺省-lt-protected-lt-public"><a href="#4-4-1-权限从小到大顺序为：private-lt-缺省-lt-protected-lt-public" class="headerlink" title="4.4.1 权限从小到大顺序为：private &lt;  缺省 &lt; protected &lt; public"></a>4.4.1 权限从小到大顺序为：private &lt;  缺省 &lt; protected &lt; public</h5><h5 id="4-4-2-具体的修饰范围："><a href="#4-4-2-具体的修饰范围：" class="headerlink" title="4.4.2 具体的修饰范围："></a>4.4.2 具体的修饰范围：</h5><p><img src="/images/%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E4%BF%AE%E9%A5%B0%E8%8C%83%E5%9B%B4.png"></p>
<h5 id="4-4-3-权限修饰符可用来修饰的结构说明："><a href="#4-4-3-权限修饰符可用来修饰的结构说明：" class="headerlink" title="4.4.3 权限修饰符可用来修饰的结构说明："></a>4.4.3 权限修饰符可用来修饰的结构说明：</h5><p>4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类<br><strong>修饰类的话，只能使用：缺省、public</strong></p>
<h3 id="5-类的结构之三：构造器"><a href="#5-类的结构之三：构造器" class="headerlink" title="5. 类的结构之三：构造器"></a>5. 类的结构之三：构造器</h3><h4 id="5-1-构造器（或构造方法）：Construtor"><a href="#5-1-构造器（或构造方法）：Construtor" class="headerlink" title="5.1 构造器（或构造方法）：Construtor"></a>5.1 构造器（或构造方法）：Construtor</h4><p>构造器的作用：</p>
<ol>
<li><strong>创建对象</strong></li>
<li><strong>初始化对象的信息</strong></li>
</ol>
<h4 id="5-2-使用说明"><a href="#5-2-使用说明" class="headerlink" title="5.2 使用说明"></a>5.2 使用说明</h4><ol>
<li>如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器</li>
<li>定义构造器的格式：权限修饰符  类名(形参列表){}</li>
<li>一个类中定义的多个构造器，彼此构成重载</li>
<li>一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</li>
<li><strong>一个类中，至少会有一个构造器。</strong></li>
</ol>
<h4 id="5-3-举例："><a href="#5-3-举例：" class="headerlink" title="5.3 举例："></a>5.3 举例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	String n;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">		age = a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-4-属性赋值的顺序"><a href="#5-4-属性赋值的顺序" class="headerlink" title="5.4 属性赋值的顺序"></a>5.4 属性赋值的顺序</h4><ol>
<li>默认初始化</li>
<li>显示初始化</li>
<li>构造器初始化</li>
<li>通过“对象.方法”或”对象.属性”的方式，赋值</li>
</ol>
<p>以上操作的顺序: 1 - 2 - 3 - 4</p>
<h4 id="5-5-JavaBean的概念"><a href="#5-5-JavaBean的概念" class="headerlink" title="5.5 JavaBean的概念"></a>5.5 JavaBean的概念</h4><pre><code> * JavaBean是一种Java语言写成的可重用组件 *  * 所谓JavaBean，是指符合如下标准的Java类 *         &gt;类是公共的 *         &gt;有一个无参的公共的构造器 *         &gt;有属性，且有对应的get.set方法 *  * 用处 *         用户可以使用JavaBean将功能、处理、值、数据库访问 *         和其他任何可以用Java代码创造的对象进行打包，并且其他开发者可以通过 *         内部的JSP页面、Servlet、其他JavaBean 、applet程序或者应用来使用这些对象。 *         用户可以认为JavaBean提供了一种随时随地的复制粘贴的功能，而不用关心任何改变。
</code></pre>
<h3 id="6-关键字：this"><a href="#6-关键字：this" class="headerlink" title="6. 关键字：this"></a>6. 关键字：this</h3><h4 id="6-1-可以调用的结构：属性、方法；构造器"><a href="#6-1-可以调用的结构：属性、方法；构造器" class="headerlink" title="6.1 可以调用的结构：属性、方法；构造器"></a>6.1 可以调用的结构：属性、方法；构造器</h4><h4 id="6-2-this调用属性、方法"><a href="#6-2-this调用属性、方法" class="headerlink" title="6.2 this调用属性、方法:"></a>6.2 this调用属性、方法:</h4><p><strong>this理解为：当前对象  或  当前正在创建的对象</strong></p>
<ol>
<li>在类的方法中，我们可以使用”this.属性”或”this.方法”的方式，调用当前对象属性或方法。但是，<pre><code>通常情况下，我们都择省略&quot;this.&quot;。特殊情况下，如果**方法的形参和类的属性同名时**，我们必须显式
的使用&quot;this.变量&quot;的方式，表明此变量是属性，而非形参。
</code></pre>
</li>
<li> 在类的构造器中，我们可以使用”this.属性”或”this.方法”的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都择省略”this.”。特殊情况下，如果<strong>构造器的形参和类的属性同名时</strong>，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</li>
</ol>
<h4 id="6-3-this调用构造器"><a href="#6-3-this调用构造器" class="headerlink" title="6.3 this调用构造器"></a>6.3 this调用构造器</h4><p>① 我们在类的构造器中，可以显式的使用”this(形参列表)”方式，调用本类中指定的其他构造器<br>② 构造器中不能通过”this(形参列表)”方式调用自己<br>③ 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了”this(形参列表)”<br>④ 规定：”this(形参列表)”必须声明在当前构造器的首行<br>⑤ 构造器内部，最多只能声明一个”this(形参列表)”，用来调用其他的构造器</p>
<h3 id="7-关键字：package-import"><a href="#7-关键字：package-import" class="headerlink" title="7. 关键字：package/import"></a>7. 关键字：package/import</h3><h4 id="7-1-package的使用"><a href="#7-1-package的使用" class="headerlink" title="7.1 package的使用"></a>7.1 package的使用</h4><h5 id="7-1-1-使用说明"><a href="#7-1-1-使用说明" class="headerlink" title="7.1.1 使用说明"></a>7.1.1 使用说明</h5><ol>
<li>为了更好的实现项目中类的管理，提供包的概念</li>
<li>使用package声明类或接口所属的包，声明在源文件的首行</li>
<li>包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”</li>
<li>每”.”一次，就代表一层文件目录。</li>
</ol>
<h5 id="7-1-2-举例："><a href="#7-1-2-举例：" class="headerlink" title="7.1.2 举例："></a>7.1.2 举例：</h5><p><strong>MVC设计模式</strong></p>
<p><img src="/images/MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png"></p>
<h5 id="7-1-3-JDK中的主要包介绍："><a href="#7-1-3-JDK中的主要包介绍：" class="headerlink" title="7.1.3 JDK中的主要包介绍："></a>7.1.3 JDK中的主要包介绍：</h5><p><img src="/images/java%E7%9A%84%E4%B8%BB%E8%A6%81package.png"></p>
<h4 id="7-2-import的使用"><a href="#7-2-import的使用" class="headerlink" title="7.2 import的使用"></a>7.2 import的使用</h4><p><strong>import:导入</strong></p>
<ol>
<li>在源文件中显式的使用import结构导入指定包下的类、接口</li>
<li>声明在包的声明和类的声明之间</li>
<li>如果需要导入多个结构，则并列写出即可</li>
<li>可以使用”xxx.*”的方式，表示可以导入xxx包下的所结构</li>
<li>如果使用的类或接口是java.lang包下定义的，则可以省略import结构</li>
<li>如果使用的类或接口是本包下定义的，则可以省略import结构</li>
<li>如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。</li>
<li>使用”xxx.*”方式表明可以调用xxx包下的所结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入</li>
<li>import static:导入指定类或接口中的静态结构:属性或方法。</li>
</ol>
<h1 id="chapter-5-面向对象-中"><a href="#chapter-5-面向对象-中" class="headerlink" title="#chapter 5: 面向对象-中"></a>#chapter 5: 面向对象-中</h1><h3 id="1-面向对象的特性二：继承性"><a href="#1-面向对象的特性二：继承性" class="headerlink" title="1. 面向对象的特性二：继承性"></a>1. 面向对象的特性二：继承性</h3><h4 id="1-1-为什么要有类的继承性"><a href="#1-1-为什么要有类的继承性" class="headerlink" title="1.1 为什么要有类的继承性?"></a>1.1 为什么要有类的继承性?</h4><ol>
<li>减少代码的冗余，提高代码的复用性</li>
<li>便于功能的扩展</li>
<li>为之后多态性的使用，提供了前提</li>
</ol>
<p><img src="/images/%E7%BB%A7%E6%89%BF.png"></p>
<h4 id="1-2-继承性的格式"><a href="#1-2-继承性的格式" class="headerlink" title="1.2 继承性的格式"></a>1.2 继承性的格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line"> *    A:子类、派生类、subclass</span><br><span class="line"> *    B:父类、超类、基类、superclass</span><br></pre></td></tr></table></figure>

<h4 id="1-3-子类继承父类以后有哪些不同"><a href="#1-3-子类继承父类以后有哪些不同" class="headerlink" title="1.3 子类继承父类以后有哪些不同?"></a>1.3 子类继承父类以后有哪些不同?</h4><ol>
<li>体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。<ul>
<li><strong>特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已</strong>。</li>
</ul>
</li>
<li>子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。<ol>
<li>子类和父类的关系，不同于子集和集合的关系。</li>
<li>extends：延展、扩展</li>
</ol>
</li>
</ol>
<h4 id="1-4-Java中继承性的说明"><a href="#1-4-Java中继承性的说明" class="headerlink" title="1.4 Java中继承性的说明"></a>1.4 Java中继承性的说明</h4><ol>
<li>一个类可以被多个子类继承。</li>
<li>Java中类的单继承性:一个类只能有一个父类</li>
<li>子父类是相对的概念。</li>
<li>子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类</li>
<li>子类继承父类以后，就获取了直接父类以及所间接父类中声明的属性和方法</li>
</ol>
<p><img src="/images/%E5%AD%90%E7%88%B6%E7%B1%BB.png"></p>
<h4 id="1-5-java-lang-Object类的理解"><a href="#1-5-java-lang-Object类的理解" class="headerlink" title="1.5 java.lang.Object类的理解"></a>1.5 java.lang.Object类的理解</h4><ol>
<li>如果我们没有显示的声明一个类的父类的话，则此类继承于java.lang.Object类</li>
</ol>
<h3 id="2-方法的重写"><a href="#2-方法的重写" class="headerlink" title="2. 方法的重写"></a>2. 方法的重写</h3><h4 id="2-1-什么是方法的重写-override-或-overwrite-？"><a href="#2-1-什么是方法的重写-override-或-overwrite-？" class="headerlink" title="2.1 什么是方法的重写(override  或  overwrite)？"></a>2.1 什么是方法的重写(override  或  overwrite)？</h4><p><font color="red">子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.</font></p>
<h4 id="2-2-应用"><a href="#2-2-应用" class="headerlink" title="2.2 应用"></a>2.2 应用</h4><p><strong>重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。</strong></p>
<h4 id="2-3-举例"><a href="#2-3-举例" class="headerlink" title="2.3 举例"></a>2.3 举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//求面积</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cylinder</span> <span class="keyword">extends</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findArea</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//求表面积</span></span><br><span class="line">&#125;</span><br><span class="line">***************</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckAccount</span> <span class="keyword">extends</span> <span class="title">Account</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-重写的规则"><a href="#2-4-重写的规则" class="headerlink" title="2.4 重写的规则"></a>2.4 重写的规则</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">方法的声明： 权限修饰符  返回值类型  方法名(形参列表) <span class="keyword">throws</span> 异常的类型&#123;</span><br><span class="line">* 						<span class="comment">//方法体</span></span><br><span class="line">* 					&#125;</span><br><span class="line">* 		约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法</span><br><span class="line">* 		① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同</span><br><span class="line">*         ② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符</span><br><span class="line">*      	&gt; 特殊情况：子类不能重写父类中声明为<span class="keyword">private</span>权限的方法</span><br><span class="line">*         ③ 返回值类型：</span><br><span class="line">*      	&gt; 父类被重写的方法的返回值类型是<span class="keyword">void</span>，则子类重写的方法的返回值类型只能是<span class="keyword">void</span></span><br><span class="line">*      	&gt; 父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</span><br><span class="line">*      	&gt; 父类被重写的方法的返回值类型是基本数据类型(比如：<span class="keyword">double</span>)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是<span class="keyword">double</span>)</span><br><span class="line">*		④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）</span><br><span class="line">*	**********************************************************************</span><br><span class="line">*    子类和父类中的同名同参数的方法要么都声明为非<span class="keyword">static</span>的（考虑重写，要么都声明为<span class="keyword">static</span>的（不是重写)。	</span><br></pre></td></tr></table></figure>



<h4 id="2-5面试题"><a href="#2-5面试题" class="headerlink" title="2.5面试题"></a>2.5面试题</h4><p>区分方法的重写和重载？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">① 二者的概念：</span><br><span class="line">② 重载和重写的具体规则</span><br><span class="line">③ 重载：不表现为多态性。</span><br><span class="line">  重写：表现为多态性。</span><br><span class="line">重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。</span><br><span class="line">所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；</span><br><span class="line"></span><br><span class="line">而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。 </span><br><span class="line"></span><br><span class="line">引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”</span><br></pre></td></tr></table></figure>



<h3 id="3-关键字：super"><a href="#3-关键字：super" class="headerlink" title="3. 关键字：super"></a>3. 关键字：super</h3><h4 id="3-1-super-关键字可以理解为-：-父类的"><a href="#3-1-super-关键字可以理解为-：-父类的" class="headerlink" title="3.1 super 关键字可以理解为 ： 父类的"></a>3.1 super 关键字可以理解为 ： 父类的</h4><h4 id="3-2-可以用来调用的结构"><a href="#3-2-可以用来调用的结构" class="headerlink" title="3.2 可以用来调用的结构:"></a>3.2 可以用来调用的结构:</h4><p>属性、方法、构造器</p>
<h4 id="3-3-super调用属性、方法"><a href="#3-3-super调用属性、方法" class="headerlink" title="3.3 super调用属性、方法"></a>3.3 super调用属性、方法</h4><ol>
<li>我们可以在子类的方法或构造器中。通过使用”super.属性”或”super.方法”的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略”super.”</li>
<li>特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性。</li>
<li>特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式，表明调用的是父类中被重写的方法。</li>
</ol>
<h4 id="3-4-super调用构造器"><a href="#3-4-super调用构造器" class="headerlink" title="3.4 super调用构造器"></a>3.4 super调用构造器</h4><ol>
<li>我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器</li>
<li>“super(形参列表)”的使用，必须声明在子类构造器的首行！</li>
<li>我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二一，不能同时出现</li>
<li>在构造器的首行，没显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器：super()</li>
<li>在类的多个构造器中，至少一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器</li>
</ol>
<h3 id="4-子类对象实例化全过程-理解"><a href="#4-子类对象实例化全过程-理解" class="headerlink" title="4. 子类对象实例化全过程(理解)"></a>4. 子类对象实例化全过程(理解)</h3><h4 id="4-1-从结果上看-继承性"><a href="#4-1-从结果上看-继承性" class="headerlink" title="4.1 从结果上看:继承性"></a>4.1 从结果上看:继承性</h4><ol>
<li>子类继承父类以后，就获取了父类中声明的属性或方法。</li>
<li>创建子类的对象，在堆空间中，就会加载所父类中声明的属性。</li>
</ol>
<h4 id="4-2-从过程上看"><a href="#4-2-从过程上看" class="headerlink" title="4.2 从过程上看"></a>4.2 从过程上看</h4><p>当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，…直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用。</p>
<p><img src="/images/super.png"></p>
<h4 id="4-3-强调说明"><a href="#4-3-强调说明" class="headerlink" title="4.3 强调说明"></a>4.3 强调说明</h4><p>虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。</p>
<p><img src="/images/%E5%88%9B%E5%BB%BA%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1.png"></p>
<h3 id="5-面向对象的特征三：多态性"><a href="#5-面向对象的特征三：多态性" class="headerlink" title="5. 面向对象的特征三：多态性"></a>5. 面向对象的特征三：多态性</h3><h4 id="5-1-多态性的理解"><a href="#5-1-多态性的理解" class="headerlink" title="5.1 多态性的理解:"></a>5.1 多态性的理解:</h4><p>可以理解为一个事物的多种形态。</p>
<h4 id="5-2-何为多态性"><a href="#5-2-何为多态性" class="headerlink" title="5.2 何为多态性:"></a>5.2 何为多态性:</h4><p><font color="red"><strong>对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）</strong></font></p>
<p>举例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Man();</span><br><span class="line">Object obj = <span class="keyword">new</span> Date();</span><br></pre></td></tr></table></figure>

<h4 id="5-3-多态性的使用：虚拟方法调用"><a href="#5-3-多态性的使用：虚拟方法调用" class="headerlink" title="5.3 多态性的使用：虚拟方法调用"></a>5.3 多态性的使用：虚拟方法调用</h4><ol>
<li> 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</li>
<li> 总结：编译，看左边；运行，看右边。</li>
</ol>
<h4 id="5-4-多态性的使用前提"><a href="#5-4-多态性的使用前提" class="headerlink" title="5.4 多态性的使用前提:"></a>5.4 多态性的使用前提:</h4><p>① 类的继承关系  ② 方法的重写</p>
<h4 id="5-5-多态性的应用举例"><a href="#5-5-多态性的应用举例" class="headerlink" title="5.5 多态性的应用举例:"></a>5.5 多态性的应用举例:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">举例一：</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Animal animal)</span></span>&#123;<span class="comment">//Animal animal = new Dog();</span></span><br><span class="line">		animal.eat();</span><br><span class="line">		animal.shout();</span><br><span class="line">	&#125;</span><br><span class="line">举例二：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">举例三：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doData</span><span class="params">(Connection conn)</span></span>&#123;<span class="comment">//conn = new MySQlConnection(); / conn = new OracleConnection();</span></span><br><span class="line">		<span class="comment">//规范的步骤去操作数据</span></span><br><span class="line"><span class="comment">//		conn.method1();</span></span><br><span class="line"><span class="comment">//		conn.method2();</span></span><br><span class="line"><span class="comment">//		conn.method3();</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-6-多态性使用的注意点："><a href="#5-6-多态性使用的注意点：" class="headerlink" title="5.6 多态性使用的注意点："></a>5.6 多态性使用的注意点：</h4><p><strong>对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</strong></p>
<h4 id="5-7-关于向上转型与向下转型"><a href="#5-7-关于向上转型与向下转型" class="headerlink" title="5.7 关于向上转型与向下转型"></a>5.7 关于向上转型与向下转型</h4><h5 id="5-7-1-向上转型：多态"><a href="#5-7-1-向上转型：多态" class="headerlink" title="5.7.1 向上转型：多态"></a>5.7.1 向上转型：多态</h5><h5 id="5-7-2-向下转型："><a href="#5-7-2-向下转型：" class="headerlink" title="5.7.2 向下转型："></a>5.7.2 向下转型：</h5><ol>
<li> 为什么使用向下转型：有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特的属性和方法？使用向下转型。</li>
<li> 如何实现向下转型：<strong>使用强制类型转换符：()</strong></li>
</ol>
<h5 id="5-7-3-使用时的注意点："><a href="#5-7-3-使用时的注意点：" class="headerlink" title="5.7.3 使用时的注意点："></a>5.7.3 使用时的注意点：</h5><ol>
<li>使用强转时，可能出现ClassCastException的异常。</li>
<li>为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。</li>
</ol>
<h5 id="5-7-4-instanceof的使用："><a href="#5-7-4-instanceof的使用：" class="headerlink" title="5.7.4 instanceof的使用："></a>5.7.4 instanceof的使用：</h5><ol>
<li>a instanceof A:判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false。</li>
<li>如果 a instanceof A返回true,则 a instanceof B也返回true.其中，类B是类A的父类。</li>
<li>要求a所属的类与类A必须是子类和父类的关系，否则编译错误。</li>
<li><img src="/images/instanceof.png"></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Person man = <span class="keyword">new</span> Man();</span><br><span class="line">       Person woman = <span class="keyword">new</span> Woman();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (man <span class="keyword">instanceof</span> Man)&#123;<span class="comment">//true</span></span><br><span class="line">           Man man1 = (Man) man;</span><br><span class="line">           man1.eat();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (woman <span class="keyword">instanceof</span> Woman)&#123;<span class="comment">//true</span></span><br><span class="line">           Woman woman1 = (Woman) woman;</span><br><span class="line">           woman1.eat();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   Man man = <span class="keyword">new</span> Man();</span><br><span class="line">   <span class="keyword">if</span> (man <span class="keyword">instanceof</span> Person)&#123;<span class="comment">//true</span></span><br><span class="line">   System.out.println(<span class="string">&quot;Man是Person的子类&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   Person person = <span class="keyword">new</span> Person();</span><br><span class="line">      <span class="keyword">if</span> (person <span class="keyword">instanceof</span> Man)&#123;<span class="comment">//false</span></span><br><span class="line">          System.out.println(<span class="string">&quot;person是Man的实例&quot;</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-8-面试题"><a href="#5-8-面试题" class="headerlink" title="5.8 面试题"></a>5.8 面试题</h4><p><strong>谈谈你对多态性的理解？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">① 实现代码的通用性。</span><br><span class="line">② Object类中定义的public boolean equals(Object obj)&#123;  &#125;</span><br><span class="line">  JDBC:使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server)</span><br><span class="line">③ 抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化）</span><br></pre></td></tr></table></figure>

<p> <strong>多态是编译时行为还是运行时行为？</strong></p>
<p>多态是运行时行为</p>
<h3 id="6-Object类的使用"><a href="#6-Object类的使用" class="headerlink" title="6. Object类的使用"></a>6. Object类的使用</h3><h4 id="6-1-java-lang-Object类的说明："><a href="#6-1-java-lang-Object类的说明：" class="headerlink" title="6.1 java.lang.Object类的说明："></a>6.1 java.lang.Object类的说明：</h4><ol>
<li>Object类是所Java类的根父类</li>
<li>如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类</li>
<li>Object类中的功能(属性、方法)就具通用性。<ol>
<li>属性：无</li>
<li>方法：equals() / toString() / getClass() /hashCode() / clone() / finalize()、wait() 、 notify()、notifyAll()</li>
</ol>
</li>
<li>Object类只声明了一个空参的构造器</li>
</ol>
<h4 id="6-2-equals-方法"><a href="#6-2-equals-方法" class="headerlink" title="6.2 equals() 方法"></a>6.2 equals() 方法</h4><h5 id="6-2-1-equals-的使用："><a href="#6-2-1-equals-的使用：" class="headerlink" title="6.2.1 equals()的使用："></a>6.2.1 equals()的使用：</h5><ol>
<li>是一个方法，而非运算符</li>
<li>只能适用于引用数据类型</li>
<li>Object类中equals()的定义：<ol>
<li>public boolean equals(Object obj) {<br> return (this == obj);<pre><code>     &#125;
</code></pre>
</li>
<li>说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</li>
</ol>
</li>
<li>像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同。</li>
<li>通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的”实体内容”是否相同。那么，<strong>我们就需要对Object类中的equals()进行重写.重写的原则：比较两个对象的实体内容是否相同.</strong></li>
</ol>
<h5 id="6-2-2-如何重写equals"><a href="#6-2-2-如何重写equals" class="headerlink" title="6.2.2 如何重写equals()"></a>6.2.2 如何重写equals()</h5><p>1.手动重写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;重写其equals()方法</span><br><span class="line">	public boolean equals(Object obj)&#123;</span><br><span class="line">		if(obj &#x3D;&#x3D; this)&#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		if(obj instanceof User)&#123;</span><br><span class="line">			User u &#x3D; (User)obj;</span><br><span class="line">			return this.age &#x3D;&#x3D; u.age &amp;&amp; this.name.equals(u.name);</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.开发中如何实现：自动生成的</p>
<h5 id="6-2-3-回顾-运算符的使用："><a href="#6-2-3-回顾-运算符的使用：" class="headerlink" title="6.2.3 回顾 == 运算符的使用："></a>6.2.3 回顾 == 运算符的使用：</h5><ol>
<li>可以使用在基本数据类型变量和引用数据类型变量中</li>
<li>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</li>
<li>== 符号使用时，必须保证符号左右两边的变量类型一致。</li>
</ol>
<h4 id="6-3-toString-方法"><a href="#6-3-toString-方法" class="headerlink" title="6.3 toString()方法"></a>6.3 toString()方法</h4><p>Object中的toString</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-3-1-toString-的使用："><a href="#6-3-1-toString-的使用：" class="headerlink" title="6.3.1 toString()的使用："></a>6.3.1 toString()的使用：</h5><ol>
<li>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()</li>
<li>Object类中toString()的定义：public String toString() {<pre><code>return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
</code></pre>
 }</li>
<li>像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回”实体内容”信息</li>
<li>自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容”</li>
</ol>
<h5 id="6-3-2-如何重写toString"><a href="#6-3-2-如何重写toString" class="headerlink" title="6.3.2 如何重写toString()"></a>6.3.2 如何重写toString()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private float height;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;name&#x3D;&#39;&quot; + name + &#39;&#x2F;&#39;&#39; +</span><br><span class="line">                &quot;, age&#x3D;&quot; + age +</span><br><span class="line">                &quot;, height&#x3D;&quot; + height +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-4-面试题："><a href="#6-4-面试题：" class="headerlink" title="6.4 面试题："></a>6.4 面试题：</h4><p>① final、finally、finalize的区别？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">final:最终的</span><br><span class="line">1.可以用来修饰：类、方法、变量</span><br><span class="line">2.具体的：</span><br><span class="line"></span><br><span class="line">2.1 final 用来修饰一个类:此类不能被其他类所继承。</span><br><span class="line"> *          比如：String类、System类、StringBuffer类</span><br><span class="line"> * </span><br><span class="line">2.2 final 用来修饰方法：表明此方法不可以被重写</span><br><span class="line"> * 			比如：Object类中getClass();</span><br><span class="line"> * </span><br><span class="line">2.3 final 用来修饰变量：此时的&quot;变量&quot;就称为是一个常量</span><br><span class="line"> * 	    1. final修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化</span><br><span class="line"> * 	    2. final修饰局部变量：</span><br><span class="line"> *        尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</span><br><span class="line"> *           </span><br><span class="line">static final 用来修饰属性：全局常量</span><br><span class="line"></span><br><span class="line">finally是配合try-catch使用的</span><br><span class="line">try&#123;</span><br><span class="line">	</span><br><span class="line">&#125;catch&#123;</span><br><span class="line"></span><br><span class="line">&#125;finally&#123;</span><br><span class="line">	表示最后执行的内容</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">finalize()是Object中的方法，当垃圾回收器将要回收对象所占内存之前被调用，即当一个对象被虚拟机宣告死亡时会先调用它finalize()方法，让此对象处理它生前的最后事情（这个对象可以趁这个时机挣脱死亡的命运）</span><br></pre></td></tr></table></figure>

<p>②  == 和 equals() 区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D; 是比较运算符  是否等于的意思</span><br><span class="line">1.可以使用在基本书记类型变量和引用数据类型变量中</span><br><span class="line">2.如果比较的是基本数据类型变量：比较两个变量报错的数据是否相等。（不一定类型要相同）</span><br><span class="line">如果比较的是引用数据类型变量则比较地址值是否相同。即两个引用是否指向同一个对象实体</span><br><span class="line">equals()是一个方法Object中的equals()与&#x3D;&#x3D;效果一样</span><br><span class="line">只能够适用于引用数据类型。</span><br><span class="line">s.equals(和x不同类型的对象)永远返回“false”</span><br></pre></td></tr></table></figure>

<h3 id="7-单元测试方法"><a href="#7-单元测试方法" class="headerlink" title="7. 单元测试方法"></a>7. 单元测试方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">* Java中的JUnit单元测试</span><br><span class="line">* </span><br><span class="line">* 步骤：</span><br><span class="line">* 1.中当前工程 - 右键择：build path - add libraries - JUnit 4 - 下一步</span><br><span class="line">* 2.创建Java类，进行单元测试。</span><br><span class="line">*   此时的Java类要求：① 此类是public的  ②此类提供公共的无参的构造器</span><br><span class="line">* 3.此类中声明单元测试方法。</span><br><span class="line">*   此时的单元测试方法：方法的权限是public,没返回值，没形参</span><br><span class="line">* </span><br><span class="line">* 4.此单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test;</span><br><span class="line">* </span><br><span class="line">* 5.声明好单元测试方法以后，就可以在方法体内测试相关的代码。</span><br><span class="line">* 6.写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test</span><br><span class="line">* </span><br><span class="line">* 说明：</span><br><span class="line">* 1.如果执行结果没任何异常：绿条</span><br><span class="line">* 2.如果执行结果出现异常：红条</span><br></pre></td></tr></table></figure>



<h3 id="8-包装类的使用"><a href="#8-包装类的使用" class="headerlink" title="8. 包装类的使用"></a>8. 包装类的使用</h3><h4 id="8-1-为什么要有-包装类"><a href="#8-1-为什么要有-包装类" class="headerlink" title="8.1 为什么要有(包装类)"></a>8.1 为什么要有(包装类)</h4><p><font color="red">为了使基本数据类型的变量具有类的特征，引入包装类</font></p>
<h4 id="8-2-基本数据类型与对应的包装类"><a href="#8-2-基本数据类型与对应的包装类" class="headerlink" title="8.2 基本数据类型与对应的包装类:"></a>8.2 基本数据类型与对应的包装类:</h4><p><img src="/images/%E5%8C%85%E8%A3%85%E7%B1%BB.png"></p>
<h4 id="8-3-需要掌握的类型间的转换：-基本数据类型、包装类、String"><a href="#8-3-需要掌握的类型间的转换：-基本数据类型、包装类、String" class="headerlink" title="8.3 需要掌握的类型间的转换：(基本数据类型、包装类、String)"></a>8.3 需要掌握的类型间的转换：(基本数据类型、包装类、String)</h4><p> <img src="/images/%E5%8C%85%E8%A3%85%E7%B1%BB%E8%BD%AC%E6%8D%A2.png"></p>
<p>简易版：<br>基本数据类型&lt;—&gt;包装类：JDK 5.0 新特性：自动装箱 与自动拆箱<br>基本数据类型、包装类—&gt;String:调用String重载的valueOf(Xxx xxx)<br>String—&gt;基本数据类型、包装类:调用包装类的parseXxx(String s)<br>     注意：转换时，可能会报NumberFormatException<br>应用场景举例：<br>① Vector类中关于添加元素，只定义了形参为Object类型的方法：<br>v.addElement(Object obj);   //基本数据类型 —&gt;包装类 —&gt;使用多态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.java2;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.experimental.theories.suppliers.TestedOn;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 包装类的使用：</span><br><span class="line"> * 1.java提供了8中基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征</span><br><span class="line"> * </span><br><span class="line"> * 2.掌握的：基本数据类型、包装类、String三者之间的相互转换</span><br><span class="line"> * </span><br><span class="line"> *&#x2F;</span><br><span class="line">public class WrapperTest &#123;&#x2F;&#x2F;Wrapper包装</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;String类型 --&gt; 基本数据类型、包装类：调用包装类的parseXxx()</span><br><span class="line">	@Test</span><br><span class="line">	public void test5()&#123;</span><br><span class="line">		String str1 &#x3D; &quot;123&quot;;</span><br><span class="line">		&#x2F;&#x2F;错误的情况</span><br><span class="line">&#x2F;&#x2F;		int num1 &#x3D; (int)str1;</span><br><span class="line">&#x2F;&#x2F;		Integer in1 &#x3D; (Integer)str1;</span><br><span class="line">		&#x2F;&#x2F;可能会报NumberFormatException</span><br><span class="line">		int num2 &#x3D; Integer.parseInt(str1);</span><br><span class="line">		System.out.println(num2 + 1);</span><br><span class="line">		</span><br><span class="line">		String str2 &#x3D; &quot;true&quot;;</span><br><span class="line">		boolean b1 &#x3D; Boolean.parseBoolean(str2);</span><br><span class="line">		System.out.println(b1);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;基本数据类型、包装类 ---&gt; String类型：调用String重载的valueOf(Xxx xxx)</span><br><span class="line">	@Test</span><br><span class="line">	public void test4()&#123;</span><br><span class="line">		int num1 &#x3D; 10;</span><br><span class="line">		&#x2F;&#x2F;方式1:连接运算</span><br><span class="line">		String str1 &#x3D; num1 + &quot;&quot;;</span><br><span class="line">		&#x2F;&#x2F;方式2：调用String的valueOf(Xxx xxx)方法</span><br><span class="line">		float f1 &#x3D; 123f;</span><br><span class="line">		String str2 &#x3D; String.valueOf(f1);</span><br><span class="line">		</span><br><span class="line">		Double d1 &#x3D; 12.4;</span><br><span class="line">		String str4 &#x3D; d1 + &quot;&quot;;</span><br><span class="line">		String str3 &#x3D; String.valueOf(d1);</span><br><span class="line">		System.out.println(d1);</span><br><span class="line">		System.out.println(str2);</span><br><span class="line">		System.out.println(str3);</span><br><span class="line">		System.out.println(str4);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * </span><br><span class="line">	 * JDK 5.0新特性：自动装箱与自动拆箱</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Test</span><br><span class="line">	public void test3()&#123;</span><br><span class="line">&#x2F;&#x2F;		int num1 &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F;		&#x2F;&#x2F;基本数据类型--&gt;包装类的对象</span><br><span class="line">&#x2F;&#x2F;		Integer in &#x3D; new Integer(num1);</span><br><span class="line">&#x2F;&#x2F;		method(in);</span><br><span class="line">&#x2F;&#x2F;		method(num1);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;自动装箱：</span><br><span class="line">		int num2 &#x3D; 10;</span><br><span class="line">		Integer in1 &#x3D; num2;&#x2F;&#x2F;自动装箱</span><br><span class="line">		</span><br><span class="line">		boolean b1 &#x3D; true;</span><br><span class="line">		Boolean b2 &#x3D; b1;&#x2F;&#x2F;自动装箱</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;自动拆箱：包装类--&gt;基本数据类型</span><br><span class="line">		System.out.println(in1.toString());</span><br><span class="line">		</span><br><span class="line">		int num3 &#x3D; in1;</span><br><span class="line">		System.out.println(num3);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;包装类 ---&gt; 基本数据类型:调用包装类的xxxValue()</span><br><span class="line">	@Test</span><br><span class="line">	public void test2()&#123;</span><br><span class="line">		&#x2F;&#x2F;包装类不能进行运算需要转化为基本数据类型进行运算</span><br><span class="line">		Integer in1 &#x3D; new Integer(12);</span><br><span class="line">		int i1 &#x3D; in1.intValue();</span><br><span class="line">		System.out.println(i1 + 1);</span><br><span class="line">		</span><br><span class="line">		Float f1 &#x3D; new Float(12.3);</span><br><span class="line">		float f &#x3D; f1.floatValue();</span><br><span class="line">		System.out.println(f + 1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;基本数据类型---&gt;包装类</span><br><span class="line">	@Test</span><br><span class="line">	public void test1()&#123;</span><br><span class="line">		</span><br><span class="line">		int num1 &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F;		System.out.println(num1.toString());</span><br><span class="line">		Integer in1 &#x3D; new Integer(num1);</span><br><span class="line">		System.out.println(in1.toString());</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;报异常</span><br><span class="line">&#x2F;&#x2F;		Integer in2 &#x3D; new Integer(&quot;123abc&quot;);</span><br><span class="line">&#x2F;&#x2F;		System.out.println(in2.toString());</span><br><span class="line">		</span><br><span class="line">		Float f1 &#x3D; new Float(12.3f);</span><br><span class="line">		Float f2 &#x3D; new Float(&quot;12.3&quot;);</span><br><span class="line">		System.out.println(f1);</span><br><span class="line">		System.out.println(f2);</span><br><span class="line">		System.out.println(&quot;*************************&quot;);</span><br><span class="line">		Boolean b1 &#x3D; new Boolean(true);</span><br><span class="line">		System.out.println(b1);</span><br><span class="line">		Boolean b2 &#x3D; new Boolean(&quot;tRue&quot;);</span><br><span class="line">		System.out.println(b2);</span><br><span class="line">		Boolean b3 &#x3D; new Boolean(&quot;true123&quot;);</span><br><span class="line">		System.out.println(b3);&#x2F;&#x2F;false</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;**************************&quot;);</span><br><span class="line">		Order order &#x3D; new Order();</span><br><span class="line">		System.out.println(order.isMale);&#x2F;&#x2F;false</span><br><span class="line">		System.out.println(order.isFemale);&#x2F;&#x2F;null</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;面试题：</span><br><span class="line">	@Test</span><br><span class="line">	public void test6()&#123;</span><br><span class="line">		Integer i &#x3D; new Integer(1);</span><br><span class="line">		Integer j &#x3D; new Integer(1);</span><br><span class="line">		System.out.println(i &#x3D;&#x3D; j);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[],</span><br><span class="line">		&#x2F;&#x2F;保存了从-128~127范围的整数。如果我们使用自动装箱的方式，给Integer赋值的范围在</span><br><span class="line">		&#x2F;&#x2F;-128~127范围内时，可以直接使用数字中的元素，不用再去new了。目的提高效率</span><br><span class="line">		</span><br><span class="line">		Integer m &#x3D; 1;</span><br><span class="line">		Integer n &#x3D; 1;</span><br><span class="line">		System.out.println(m &#x3D;&#x3D; n);</span><br><span class="line">		</span><br><span class="line">		Integer x &#x3D; 128;&#x2F;&#x2F;相当于new了一个Integer对象</span><br><span class="line">		Integer y &#x3D; 128;&#x2F;&#x2F;相当于new了一个Integer对象</span><br><span class="line">		System.out.println(x &#x3D;&#x3D; y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Order&#123;</span><br><span class="line">	boolean isMale;</span><br><span class="line">	Boolean isFemale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="chapter-6：面向对象-下"><a href="#chapter-6：面向对象-下" class="headerlink" title="#chapter 6：面向对象-下"></a>#chapter 6：面向对象-下</h1><h3 id="1-关键字：static"><a href="#1-关键字：static" class="headerlink" title="1. 关键字：static"></a>1. 关键字：static</h3><p><strong>static:静态的</strong></p>
<h4 id="1-1-可以用来修饰的结构："><a href="#1-1-可以用来修饰的结构：" class="headerlink" title="1.1 可以用来修饰的结构："></a>1.1 可以用来修饰的结构：</h4><p>主要用来修饰的内部结构</p>
<p><strong>属性、方法、代码块、内部类</strong></p>
<h4 id="1-2-static修饰属性-静态变量-或类变量"><a href="#1-2-static修饰属性-静态变量-或类变量" class="headerlink" title="1.2 static修饰属性:静态变量(或类变量)"></a>1.2 static修饰属性:静态变量(或类变量)</h4><ol>
<li><p>属性，是否使用static修饰，又分为：静态属性  vs 非静态属性(实例变量)</p>
<ol>
<li>实例变量：我们创建了类的多个对象，每个对象都独立的拥一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</li>
<li>静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</li>
</ol>
</li>
<li><p>static修饰属性的其他说明：</p>
<ol>
<li><p>静态变量随着类的加载而加载。可以通过”类.静态变量”的方式进行调用</p>
</li>
<li><p>静态变量的加载要早于对象的创建。</p>
</li>
<li><p>由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。</p>
</li>
<li><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">类变量</th>
<th align="center">实例变量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类</td>
<td align="center">yes</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">对象</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
<li><p>静态属性举例：System.out; Math.PI;</p>
</li>
</ol>
<h4 id="1-3-静态变量内存解析："><a href="#1-3-静态变量内存解析：" class="headerlink" title="1.3 静态变量内存解析："></a>1.3 静态变量内存解析：</h4><p><img src="/images/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90.png"></p>
<h4 id="1-4-static修饰方法：静态方法、类方法"><a href="#1-4-static修饰方法：静态方法、类方法" class="headerlink" title="1.4 static修饰方法：静态方法、类方法"></a>1.4 static修饰方法：静态方法、类方法</h4><ol>
<li><p>随着类的加载而加载，可以通过”类.静态方法”的方式进行调用</p>
</li>
<li><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">静态方法</th>
<th align="center">非静态方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类</td>
<td align="center">yes</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">对象</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
</tbody></table>
</li>
<li><p>静态方法中，只能调用静态的方法或属性</p>
</li>
<li><p>非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</p>
</li>
</ol>
<h4 id="1-5-static的注意点："><a href="#1-5-static的注意点：" class="headerlink" title="1.5 static的注意点："></a>1.5 static的注意点：</h4><ol>
<li>在静态的方法内，不能使用this关键字、super关键字</li>
<li>关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。</li>
</ol>
<h4 id="1-6-如何判定属性和方法应该使用static关键字："><a href="#1-6-如何判定属性和方法应该使用static关键字：" class="headerlink" title="1.6 如何判定属性和方法应该使用static关键字："></a>1.6 如何判定属性和方法应该使用static关键字：</h4><h5 id="1-6-1-关于属性"><a href="#1-6-1-关于属性" class="headerlink" title="1.6.1 关于属性"></a>1.6.1 关于属性</h5><ol>
<li>属性是可以被多个对象所共享的，不会随着对象的不同而不同的。</li>
<li>类中的常量也常常声明为static</li>
</ol>
<h5 id="1-6-2-关于方法"><a href="#1-6-2-关于方法" class="headerlink" title="1.6.2 关于方法"></a>1.6.2 关于方法</h5><ol>
<li>操作静态属性的方法，通常设置为static的</li>
<li>工具类中的方法，习惯上声明为static的。比如:Math、Arrays、Collections</li>
</ol>
<h4 id="1-7-使用举例："><a href="#1-7-使用举例：" class="headerlink" title="1.7 使用举例："></a>1.7 使用举例：</h4><ol>
<li><p>Arrays、Math、Collections等工具类</p>
</li>
<li><p>单例模式</p>
</li>
<li><p>````<br>class Circle{</p>
<pre><code>private double radius;
private int id;//自动赋值

public Circle()&#123;
    id = init++;
    total++;
&#125;

public Circle(double radius)&#123;
    this();
</code></pre>
<p>//        id = init++;<br>//        total++;</p>
<pre><code>    this.radius = radius;
    
&#125;

private static int total;//记录创建的圆的个数
private static int init = 1001;//static声明的属性被所对象所共享

public double findArea()&#123;
    return 3.14 * radius * radius;
&#125;

public double getRadius() &#123;
    return radius;
&#125;

public void setRadius(double radius) &#123;
    this.radius = radius;
&#125;

public int getId() &#123;
    return id;
&#125;

public static int getTotal() &#123;
    return total;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2. main()的使用说明</span><br><span class="line"></span><br><span class="line">1. main()方法作为程序的入口</span><br><span class="line"></span><br><span class="line">2. main()方法也是一个普通的静态方法</span><br><span class="line"></span><br><span class="line">3. main()方法可以作为我们与控制台交互的方式。（之前：使用Scanner）</span><br><span class="line"></span><br><span class="line">4. ![](&#x2F;images&#x2F;main.png)</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">### 3. 类的结构：代码块</span><br><span class="line"></span><br><span class="line">**类的成员之四：代码块(初始化块)（重要性较属性、方法、构造器差一些）**</span><br><span class="line"></span><br><span class="line">#### 3.1 代码块的作用:</span><br><span class="line"></span><br><span class="line">&lt;font color &#x3D;red&gt;用来初始化类、对象的信息&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">#### 3.2 分类:</span><br><span class="line"></span><br><span class="line">**代码块要是使用修饰符，只能使用static**</span><br><span class="line"></span><br><span class="line">分类：静态代码块  vs 非静态代码块</span><br><span class="line"></span><br><span class="line">##### 3.2.1 静态代码块</span><br><span class="line"></span><br><span class="line">1. 内部可以输出语句</span><br><span class="line">2. 随着类的加载而执行,而且只执行一次</span><br><span class="line">3. 作用：初始化类的信息</span><br><span class="line">4. 如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</span><br><span class="line">5. 静态代码块的执行要优先于非静态代码块的执行</span><br><span class="line">6. 静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</span><br><span class="line"></span><br><span class="line">##### 3.2.2 非静态代码块</span><br><span class="line"></span><br><span class="line">1. 内部可以输出语句</span><br><span class="line">2. 随着对象的创建而执行</span><br><span class="line">3. 每创建一个对象，就执行一次非静态代码块</span><br><span class="line">4. 作用：可以在创建对象时，对对象的属性等进行初始化</span><br><span class="line">5. 如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</span><br><span class="line">6. 非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</span><br><span class="line"></span><br><span class="line">#### 3.3 实例化子类对象时的加载顺序</span><br><span class="line"></span><br><span class="line">**由父及子，静态先行。**</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>代码运行的规则：<pre><code>    由父及子，静态先行
   
 父类-静态属性 
 父类-静态代码块 
 静态属性 
 静态代码块 
 父类-非静态属性 
 父类-非静态代码块 
 父类—无参构造函数 
 非静态属性 
 非静态代码块 
 无参构造函数
 
</code></pre>
</li>
<li>①默认初始化</li>
<li>②显式初始化/⑤在代码块中赋值</li>
<li>③构造器中初始化</li>
<li>④有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值</li>
<li></li>
<li></li>
<li>执行的先后顺序：① - ② / ⑤ - ③ - ④<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 4. 关键字final</span><br><span class="line"></span><br><span class="line">**final:最终的**</span><br><span class="line"></span><br><span class="line">#### 4.1 可以用来修饰什么?</span><br><span class="line"></span><br><span class="line">&lt;font color&#x3D;red&gt;类、方法、变量&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">#### 4.2 具体的：</span><br><span class="line"></span><br><span class="line">1. final 用来修饰一个类:此类不能被其他类所继承。比如：String类、System类、StringBuffer类</span><br><span class="line">2. final 用来修饰方法：表明此方法不可以被重写。比如：Object类中getClass();</span><br><span class="line">3. final 用来修饰变量：此时的&quot;变量&quot;就称为是一个常量</span><br><span class="line">   1. final修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化</span><br><span class="line">   2. final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</span><br><span class="line">4. &lt;font color&#x3D;red&gt;static final 用来修饰属性：全局常量&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">### 5. 关键字abstract</span><br><span class="line"></span><br><span class="line">**abstract: 抽象的**</span><br><span class="line"></span><br><span class="line">#### 5.1 可以用来修饰什么?</span><br><span class="line"></span><br><span class="line">**类、方法**</span><br><span class="line"></span><br><span class="line">#### 5.2 具体的：</span><br><span class="line"></span><br><span class="line">1. abstract修饰类：抽象类</span><br><span class="line">   1. 此类不能实例化</span><br><span class="line">   2. 抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）</span><br><span class="line">   3. 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 ---&gt;抽象的使用前提：继承性</span><br><span class="line">2. abstract修饰方法：抽象方法</span><br><span class="line">   1. 抽象方法只有方法的声明，没方法体</span><br><span class="line">   2. 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</span><br><span class="line">   3. 若子类重写了父类中的所的抽象方法后，此子类方可实例化若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</span><br><span class="line"></span><br><span class="line">#### 5.3 注意点：</span><br><span class="line"></span><br><span class="line">1. abstract不能用来修饰：属性、构造器等结构</span><br><span class="line">2. abstract不能用来修饰私方法、静态方法、final的方法、final的类</span><br><span class="line"></span><br><span class="line">#### 5.4 abstract的应用举例:</span><br><span class="line"></span><br><span class="line">![](&#x2F;images&#x2F;abstract.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 5.5 模板方法的设计</span><br><span class="line"></span><br><span class="line">##### 5.5.1 解决的问题</span><br><span class="line"></span><br><span class="line">&lt;font color&#x3D;red&gt;在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变</span><br><span class="line">部分可以抽象出来，供不同子类实现。这就是一种模板模式。&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">##### 5.5.2 举例</span><br><span class="line"></span><br></pre></td></tr></table></figure>
//计算某段代码执行所需要花费的时间<br> public void spendTime(){<pre><code> long start = System.currentTimeMillis();
 
 this.code();//不确定的部分、易变的部分
 
 long end = System.currentTimeMillis();
 
 System.out.println(&quot;花费的时间为：&quot; + (end - start));
 
</code></pre>
 } public abstract void code();</li>
</ul>
<p>}</p>
<p>class SubTemplate extends Template{</p>
<pre><code>@Override
public void code() &#123;
    
    for(int i = 2;i &lt;= 1000;i++)&#123;
        boolean isFlag = true;
        for(int j = 2;j &lt;= Math.sqrt(i);j++)&#123;
            
            if(i % j == 0)&#123;
                isFlag = false;
                break;
            &#125;
        &#125;
        if(isFlag)&#123;
            System.out.println(i);
        &#125;
    &#125;

&#125;
</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 5.5.3 应用场景</span><br><span class="line"></span><br><span class="line">![](&#x2F;images&#x2F;应用场景.png)</span><br><span class="line"></span><br><span class="line">### 6. 关键字interface</span><br><span class="line"></span><br><span class="line">**interface:接口**</span><br><span class="line"></span><br><span class="line">#### 6.1 使用说明:</span><br><span class="line"></span><br><span class="line">1. 接口使用interface来定义</span><br><span class="line">2. Java中，接口和类是并列的两个结构</span><br><span class="line">3. 如何定义接口：定义接口中的成员</span><br><span class="line">   1. JDK7及以前：只能定义全局常量和抽象方法</span><br><span class="line">      1. 全局常量：public static final的.但是书写时，可以省略不写</span><br><span class="line">      2. 抽象方法：public abstract的</span><br><span class="line">   2. JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略</span><br><span class="line">4. 接口中不能定义构造器的！意味着接口不可以实例化</span><br><span class="line">5. Java开发中，接口通过让类去实现(implements)的方式来使用.如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类</span><br><span class="line">6. Java类可以实现多个接口   ---&gt;弥补了Java单继承性的局限性</span><br><span class="line">7. 格式：class AA extends BB implements CC,DD,EE</span><br><span class="line">8. 接口与接口之间可以继承，而且可以多继承</span><br><span class="line">9. 接口的具体使用，体现多态性</span><br><span class="line">10. 接口，实际上可以看做是一种规范</span><br><span class="line"></span><br><span class="line">#### 6.2 举例：</span><br><span class="line"></span><br><span class="line">![](&#x2F;images&#x2F;interface.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>class Computer{</p>
<pre><code>public void transferData(USB usb)&#123;//USB usb = new Flash();
    usb.start();
    
    System.out.println(&quot;具体传输数据的细节&quot;);
    
    usb.stop();
&#125;
</code></pre>
<p>}</p>
<p>interface USB{<br>    //常量：定义了长、宽、最大最小的传输速度等</p>
<pre><code>void start();

void stop();
</code></pre>
<p>}</p>
<p>class Flash implements USB{</p>
<pre><code>@Override
public void start() &#123;
    System.out.println(&quot;U盘开启工作&quot;);
&#125;

@Override
public void stop() &#123;
    System.out.println(&quot;U盘结束工作&quot;);
&#125;
</code></pre>
<p>}</p>
<p>class Printer implements USB{<br>    @Override<br>    public void start() {<br>        System.out.println(“打印机开启工作”);<br>    }</p>
<pre><code>@Override
public void stop() &#123;
    System.out.println(&quot;打印机结束工作&quot;);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">体会：</span><br><span class="line"></span><br><span class="line">1. 接口使用上也满足多态性</span><br><span class="line">2. 接口，实际上就是定义了一种规范</span><br><span class="line">3. 开发中，体会面向接口编程！	</span><br><span class="line"></span><br><span class="line">#### 6.3 体会面向接口编程的思想</span><br><span class="line"></span><br><span class="line">![](&#x2F;images&#x2F;JDBC.png)</span><br><span class="line"></span><br><span class="line">面向接口编程：我们在应用程序中，调用的结构都是JDBC中定义的接口，不会出现具体某一个</span><br><span class="line">数据库厂商的API。</span><br><span class="line"></span><br><span class="line">#### 6.4 Java8中关于接口的新规范</span><br><span class="line"></span><br><span class="line">1. 接口中定义的静态方法，只能通过接口来调用。</span><br><span class="line">2. 如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</span><br><span class="line">3. 如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。--&gt;类优先原则</span><br><span class="line">4. 如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么在实现类没重写此方法的情况下，报错。--&gt;接口冲突。这就需要我们必须在实现类中重写此方法</span><br><span class="line">5. 如何在子类(或实现类)的方法中调用父类、接口中被重写的方法public void myMethod()&#123;</span><br><span class="line">   	method3();&#x2F;&#x2F;调用自己定义的重写的方法</span><br><span class="line">      		super.method3();&#x2F;&#x2F;调用的是父类中声明的</span><br><span class="line">      		&#x2F;&#x2F;调用接口中的默认方法</span><br><span class="line">      		CompareA.super.method3();</span><br><span class="line">      		CompareB.super.method3();</span><br><span class="line">      	&#125;</span><br><span class="line"></span><br><span class="line">#### 6.5 面试题</span><br><span class="line"></span><br><span class="line">**抽象类和接口的异同？**</span><br><span class="line"></span><br><span class="line">**相同点**：不能实例化；都可以包含抽象方法的。</span><br><span class="line"></span><br><span class="line">**不同点：**</span><br><span class="line"></span><br><span class="line">1. 把抽象类和接口(java7,java8,java9)的定义、内部结构解释说明</span><br><span class="line">2. 类：单继承性    接口：多继承   类与接口：多实现</span><br><span class="line"></span><br><span class="line">#### 6.6 代理模式</span><br><span class="line"></span><br><span class="line">##### 6.6.1 解决的问题</span><br><span class="line"></span><br><span class="line">代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。 </span><br><span class="line"></span><br><span class="line">##### 6.6.2 举例</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>interface NetWork{</p>
<pre><code>public void browse();
</code></pre>
<p>}</p>
<p>//被代理类<br>class Server implements NetWork{</p>
<pre><code>@Override
public void browse() &#123;
    System.out.println(&quot;真实的服务器访问网络&quot;);
&#125;
</code></pre>
<p>}<br>//代理类<br>class ProxyServer implements NetWork{</p>
<pre><code>private NetWork work;

public ProxyServer(NetWork work)&#123;
    this.work = work;
&#125;


public void check()&#123;
    System.out.println(&quot;联网之前的检查工作&quot;);
&#125;

@Override
public void browse() &#123;
    check();
    
    work.browse();
    
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 6.6.3 应用场景</span><br><span class="line"></span><br><span class="line">![](&#x2F;images&#x2F;代理模式.png)</span><br><span class="line"></span><br><span class="line">#### 6.7 工厂设计模式</span><br><span class="line"></span><br><span class="line">##### 6.7.1 解决的问题</span><br><span class="line"></span><br><span class="line">**实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。**</span><br><span class="line"></span><br><span class="line">##### 6.7.2 具体模式</span><br><span class="line"></span><br><span class="line">简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）</span><br><span class="line"></span><br><span class="line">工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品)</span><br><span class="line"></span><br><span class="line">抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族)</span><br><span class="line"></span><br><span class="line">### 7. 类的结构：内部类</span><br><span class="line"></span><br><span class="line">内部类：类的第五个成员</span><br><span class="line"></span><br><span class="line">#### 7.1 定义</span><br><span class="line"></span><br><span class="line">**Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类.**</span><br><span class="line"></span><br><span class="line">#### 7.2 内部类的分类</span><br><span class="line"></span><br><span class="line">成员内部类（静态、非静态 ） vs 局部内部类(方法内、代码块内、构造器内)</span><br><span class="line"></span><br><span class="line">#### 7.3 成员内部类的理解</span><br><span class="line"></span><br><span class="line">一方面，作为外部类的成员：</span><br><span class="line"></span><br><span class="line">1. 调用外部类的结构</span><br><span class="line">2. 可以被static修饰</span><br><span class="line">3. 可以被4种不同的权限修饰</span><br><span class="line"></span><br><span class="line">另一方面，作为一个类：</span><br><span class="line"></span><br><span class="line">1. 类内可以定义属性、方法、构造器等</span><br><span class="line">2. 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</span><br><span class="line">3. 可以被abstract修饰</span><br><span class="line"></span><br><span class="line">#### 7.4 成员内部类</span><br><span class="line"></span><br><span class="line">##### 7.4.1 如何创建成员内部类的对象？(静态的，非静态的)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建静态的Dog内部类的实例(静态的成员内部类):</span><br><span class="line"></span><br><span class="line">**Person.Dog dog &#x3D; new Person.Dog();**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建非静态的Bird内部类的实例(非静态的成员内部类):</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Person.Bird bird &#x3D; new Person.Bird();&#x2F;&#x2F;错误的</span><br><span class="line">Person p &#x3D; new Person();</span><br><span class="line">Person.Bird bird &#x3D; p.new Bird();</span><br><span class="line"></span><br><span class="line">##### 7.4.2 如何在成员内部类中调用外部类的结构？</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>class Person{<br>    String name = “小明”;<br>public void eat(){<br>}<br>//非静态成员内部类<br>    class Bird{<br>        String name = “杜鹃”;<br>        public void display(String name){<br>            System.out.println(name);//方法的形参<br>            System.out.println(this.name);//内部类的属性<br>            System.out.println(Person.this.name);//外部类的属性<br>        //Person.this.eat();<br>        }<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 7.5 局部内部类的使用：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>//返回一个实现了Comparable接口的类的对象<br>    public Comparable getComparable(){</p>
<pre><code>    //创建一个实现了Comparable接口的类:局部内部类
    //方式一：
</code></pre>
<p>//        class MyComparable implements Comparable{<br>//<br>//            @Override<br>//            public int compareTo(Object o) {<br>//                return 0;<br>//            }<br>//<br>//        }<br>//<br>//        return new MyComparable();</p>
<pre><code>    //方式二：
    return new Comparable()&#123;

        @Override
        public int compareTo(Object o) &#123;
            return 0;
        &#125;
        
    &#125;;//匿名内部类
    
&#125; 
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**注意点：**</span><br><span class="line">在局部内部类的方法中（比如：show如果调用局部内部类所声明的方法(比如：method)中的局部变量(比如：num)的话,要求此局部变量声明为final的。</span><br><span class="line"></span><br><span class="line">jdk 7及之前版本：要求此局部变量显式的声明为final的</span><br><span class="line"></span><br><span class="line">jdk 8及之后的版本：可以省略final的声明</span><br><span class="line"></span><br><span class="line">**总结：**</span><br><span class="line">成员内部类和局部内部类，在编译以后，都会生成字节码文件。</span><br><span class="line">格式：成员内部类：外部类$内部类名.class</span><br><span class="line">        局部内部类：外部类$数字 内部类名.class</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># #chapter 7： 异常处理</span><br><span class="line"></span><br><span class="line">### 1. 异常</span><br><span class="line"></span><br><span class="line">#### 1.1  异常的体系结构</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>java.lang.Throwable</li>
<li><pre><code>    |-----java.lang.Error:一般不编写针对性的代码进行处理。
</code></pre>
</li>
<li><pre><code>    |-----java.lang.Exception:可以进行异常的处理
</code></pre>
</li>
<li><pre><code>        |------编译时异常(checked)
</code></pre>
</li>
<li><pre><code>                |-----IOException
</code></pre>
</li>
<li><pre><code>                    |-----FileNotFoundException
</code></pre>
</li>
<li><pre><code>                |-----ClassNotFoundException
</code></pre>
</li>
<li><pre><code>        |------运行时异常(unchecked,RuntimeException)
</code></pre>
</li>
<li><pre><code>                |-----NullPointerException
</code></pre>
</li>
<li><pre><code>                |-----ArrayIndexOutOfBoundsException
</code></pre>
</li>
<li><pre><code>                |-----ClassCastException
</code></pre>
</li>
<li><pre><code>                |-----NumberFormatException
</code></pre>
</li>
<li><pre><code>                |-----InputMismatchException
</code></pre>
</li>
<li><pre><code>             |-----ArithmeticException
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![](&#x2F;images&#x2F;Exception.png)</span><br><span class="line"></span><br><span class="line">#### 1.2 从程序执行过程，看编译时异常和运行时异常</span><br><span class="line"></span><br><span class="line">![](&#x2F;images&#x2F;Exception2.png)</span><br><span class="line"></span><br><span class="line">**编译时异常：执行javac.exe命名时，可能出现的异常**</span><br><span class="line"></span><br><span class="line">**运行时异常：执行java.exe命名时，出现的异常**</span><br><span class="line"></span><br><span class="line">#### 1.3 常见的异常类型，请举例说明：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
//<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>以下是运行时异常</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>*<br> //ArithmeticException算术异常<br> //违背数学规律<br> @Test<br> public void test6(){<pre><code> int a = 10;
 int b = 0;
 System.out.println(a / b);
</code></pre>
 }</li>
</ul>
<pre><code>//InputMismatchException输入不匹配异常
@Test
public void test5()&#123;
    Scanner scanner = new Scanner(System.in);
    int score = scanner.nextInt();
    System.out.println(score);
    
    scanner.close();
&#125;

//NumberFormatException数字格式异常
@Test
public void test4()&#123;
    
    String str = &quot;123&quot;; 
</code></pre>
<p>//        str = “abc”;<br>        int n = Integer.parseInt(str);<br>    }</p>
<pre><code>//ClassCastException类转换异常
@Test
public void test3()&#123;
</code></pre>
<p>//        Object obj = new Date();<br>//        String str = (String)obj;<br>    }</p>
<pre><code>//ArrayIndexOutOfBoundsException
@Test
public void test2()&#123;
    //ArrayIndexOutOfBoundsException
</code></pre>
<p>//        int[] arr = new int[10];<br>//        System.out.println(arr[10]);</p>
<pre><code>    //StringIndexOutOfBoundsException
</code></pre>
<p>//        String str = “abc”;<br>//        System.out.println(str.charAt(3));<br>    }<br>    //NullPointerException空指针异常<br>    @Test<br>    public void test1(){<br>//        int[] arr = null;<br>//        System.out.println(arr[3]);</p>
<p>//        String str = “abc”;<br>//        str = null;<br>//        System.out.println(str.charAt(0));<br>    }<br>//    public static void main(String[] args) {<br>//<br>//    }</p>
<p>//<strong><strong><strong><strong><strong><strong><strong><strong><strong>以下是编译时异常</strong></strong></strong></strong></strong></strong></strong></strong></strong>*********<br>    @Test<br>    public void test7(){<br>//        File file = new File(“hello.txt”);<br>//        FileInputStream fis = new FileInputStream(file);<br>//<br>//        int data = fis.read();<br>//        while(data != -1){<br>//            System.out.print((char)data);<br>//            data = fis.read();<br>//        }<br>//<br>//        fis.close();</p>
<pre><code>&#125;
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2. 异常的处理</span><br><span class="line"></span><br><span class="line">#### 2.1 java异常处理的抓抛模型</span><br><span class="line"></span><br><span class="line">**过程一：&quot;抛&quot;：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。 并将此对象抛出。一旦抛出对象以后，其后的代码就不再执行。**</span><br><span class="line"></span><br><span class="line">关于异常对象的产生：① 系统自动生成的异常对象   ② 手动的生成一个异常对象，并抛出（throw）</span><br><span class="line"></span><br><span class="line">**过程二：&quot;抓&quot;：可以理解为异常的处理方式：① try-catch-finally  ② throws**</span><br><span class="line"></span><br><span class="line">#### 2.2 异常处理方式一：try-catch-finally</span><br><span class="line"></span><br><span class="line">##### 2.2.1 使用说明：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>try{</p>
<ul>
<li><pre><code>    //可能出现异常的代码
</code></pre>
</li>
<li></li>
<li>}catch(异常类型1 变量名1){</li>
<li><pre><code>    //处理异常的方式1
</code></pre>
</li>
<li>}catch(异常类型2 变量名2){</li>
<li><pre><code>    //处理异常的方式2
</code></pre>
</li>
<li>}catch(异常类型3 变量名3){</li>
<li><pre><code>    //处理异常的方式3
</code></pre>
</li>
<li>}</li>
<li>….</li>
<li>finally{</li>
<li><pre><code>    //一定会执行的代码
</code></pre>
</li>
<li>}</li>
<li>说明：</li>
<li><ol>
<li>finally是可有可无的。</li>
</ol>
</li>
<li><ol start="2">
<li>使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配</li>
</ol>
</li>
<li><ol start="3">
<li>一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的try-catch结构（在没写finally的情况。继续执行其后的代码</li>
</ol>
</li>
<li><ol start="4">
<li>catch中的异常类型如果没子父类关系，则谁声明在上，谁声明在下无所谓。</li>
</ol>
</li>
<li>   catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错</li>
<li><ol start="5">
<li>常用的异常对象处理的方式： ① String  getMessage()    ② printStackTrace()</li>
</ol>
</li>
<li><ol start="6">
<li>在try结构中声明的变量，再出了try结构以后，就不能再被调用</li>
</ol>
</li>
<li><ol start="7">
<li>try-catch-finally结构可以嵌套</li>
</ol>
</li>
</ul>
<p> int a, b;<br>        @Test<br>        public void test2(){<br>               try{<br>                       int temp = a / 0;<br>               }catch (Exception e){<br>                        e.printStackTrace();<br>               }</p>
<pre><code>            System.out.println(&quot;try-catch后的代码&quot;);
    &#125;
    
    //结果
    java.lang.ArithmeticException: / by zero
    try-catch后的代码
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**总结：如何看待代码中的编译时异常和运行时异常？**</span><br><span class="line"></span><br><span class="line">1.  体会1：使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。</span><br><span class="line">2.  体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。针对于编译时异常，我们说一定要考虑异常的处理。</span><br><span class="line"></span><br><span class="line">##### 2.2.2 finally的再说明：</span><br><span class="line"></span><br><span class="line">1. finally是可的</span><br><span class="line">2. finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中return语句，catch中return语句等情况。</span><br><span class="line">3. 像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。</span><br><span class="line"></span><br><span class="line">##### 2.2.3 [面试题] </span><br><span class="line"></span><br><span class="line">final、finally、finalize三者的区别？</span><br><span class="line"></span><br><span class="line">类似：</span><br><span class="line">throw 和 throws</span><br><span class="line">Collection 和 Collections</span><br><span class="line">String 、StringBuffer、StringBuilder</span><br><span class="line">ArrayList 、 LinkedList</span><br><span class="line">HashMap 、LinkedHashMap</span><br><span class="line">重写、重载</span><br><span class="line"></span><br><span class="line">结构不相似的：</span><br><span class="line">抽象类、接口</span><br><span class="line">&#x3D;&#x3D; 、 equals()</span><br><span class="line">sleep()、wait()</span><br><span class="line"></span><br><span class="line">#### 2.3 异常处理方式二：</span><br><span class="line"></span><br><span class="line">&quot;throws + 异常类型&quot;写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。</span><br><span class="line"></span><br><span class="line">一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> int a, b;<br>        @Test<br>        public void test2() throws Exception{<br>                       int temp = a / 0;</p>
<pre><code>            System.out.println(&quot;try-catch后的代码&quot;);
    &#125;
    //结果
    java.lang.ArithmeticException: / by zero
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.4 对比两种处理方式</span><br><span class="line"></span><br><span class="line">1. try-catch-finally:真正的将异常给处理掉了。</span><br><span class="line">2. throws的方式只是将异常抛给了方法的调用者。并没真正将异常处理掉。 </span><br><span class="line"></span><br><span class="line">#### 2.5 会开发中应该如何选择两种处理方式？</span><br><span class="line"></span><br><span class="line">1. 如果父类中被重写的方法没throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中异常，必须使用try-catch-finally方式处理。</span><br><span class="line">2. 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。</span><br><span class="line"></span><br><span class="line">**补充：**</span><br><span class="line">方法重写的规则之一：</span><br><span class="line">子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</span><br><span class="line"></span><br><span class="line">### 3. 手动抛出异常</span><br><span class="line"></span><br><span class="line">#### 3.1 使用说明</span><br><span class="line"></span><br><span class="line">在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的throw一个异常类的对象。</span><br><span class="line"></span><br><span class="line">#### 3.2 [面试题] </span><br><span class="line"></span><br><span class="line">**throw 和  throws区别：**</span><br><span class="line">**throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。**</span><br><span class="line">**throws 属于异常处理的一种方式，声明在方法的声明处。**</span><br><span class="line"></span><br><span class="line">#### 3.3 典型例题</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>class Student{</p>
<pre><code>private int id;

public void regist(int id) throws Exception &#123;
    if(id &gt; 0)&#123;
        this.id = id;
    &#125;else&#123;
        //手动抛出异常对象
</code></pre>
<p>//            throw new RuntimeException(“您输入的数据非法！”);<br>//            throw new Exception(“您输入的数据非法！”);<br>            throw new MyException(“不能输入负数”);</p>
<pre><code>    &#125;
    
&#125;

@Override
public String toString() &#123;
    return &quot;Student [id=&quot; + id + &quot;]&quot;;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 4. 自定义异常</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;&#96;java</span><br><span class="line">如何自定义一个异常类？</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 如何自定义异常类？</span><br><span class="line"> * 1. 继承于现的异常结构：RuntimeException 、Exception</span><br><span class="line"> * 2. 提供全局常量：serialVersionUID</span><br><span class="line"> * 3. 提供重载的构造器</span><br><span class="line"> * </span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MyException extends Exception&#123;</span><br><span class="line">	</span><br><span class="line">	static final long serialVersionUID &#x3D; -7034897193246939L;</span><br><span class="line">	</span><br><span class="line">	public MyException()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public MyException(String msg)&#123;</span><br><span class="line">		super(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">John Doe</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2021/04/07/JavaSE%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/">http://example.com/2021/04/07/JavaSE%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint policy. If reproduced, please indicate source
                    <a href="/about" target="_blank">John Doe</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">No tag</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2021/04/07/JavaSE%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="JavaSE学习高级篇">
                        
                        <span class="card-title">JavaSE学习高级篇</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-04-07
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            John Doe
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/04/05/JSON%E7%AC%94%E8%AE%B0/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="JSON笔记">
                        
                        <span class="card-title">JSON笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-04-05
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            John Doe
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2021</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">John Doe</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/smallfeifei123" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1538211161@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1538211161" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1538211161" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
